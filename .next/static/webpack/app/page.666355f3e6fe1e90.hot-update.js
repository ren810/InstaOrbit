"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/client/InteractiveGrid.tsx":
/*!***************************************************!*\
  !*** ./src/components/client/InteractiveGrid.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InteractiveGrid: function() { return /* binding */ InteractiveGrid; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ InteractiveGrid auto */ \nvar _s = $RefreshSig$();\n\nconst GRID_BLOCK_SIZE = 60;\nconst GRID_HIGHLIGHT_DURATION = 300;\nconst InteractiveGrid = ()=>{\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const blocksRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const animationFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const mouseRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        x: undefined,\n        y: undefined,\n        radius: GRID_BLOCK_SIZE * 2\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Safety check for server-side rendering\n        if (false) {}\n        const container = containerRef.current;\n        if (!container) return;\n        const createBlock = (posX, posY, gridX, gridY)=>{\n            const el = document.createElement(\"div\");\n            el.className = \"block\";\n            el.style.cssText = \"\\n        position: absolute;\\n        background-color: transparent;\\n        border: 0.5px solid #262626;\\n        transition: border-color 0.3s ease;\\n        box-sizing: border-box;\\n        will-change: transform;\\n        width: \".concat(GRID_BLOCK_SIZE, \"px;\\n        height: \").concat(GRID_BLOCK_SIZE, \"px;\\n        left: \").concat(posX, \"px;\\n        top: \").concat(posY, \"px;\\n      \");\n            container.appendChild(el);\n            return {\n                element: el,\n                x: posX + GRID_BLOCK_SIZE / 2,\n                y: posY + GRID_BLOCK_SIZE / 2,\n                gridX,\n                gridY,\n                highlightEndTime: 0\n            };\n        };\n        const initGrid = ()=>{\n            container.innerHTML = \"\";\n            blocksRef.current = [];\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n            const cols = Math.ceil(width / GRID_BLOCK_SIZE);\n            const rows = Math.ceil(height / GRID_BLOCK_SIZE);\n            const offsetX = (width - cols * GRID_BLOCK_SIZE) / 2;\n            const offsetY = (height - rows * GRID_BLOCK_SIZE) / 2;\n            for(let r = 0; r < rows; r++){\n                for(let c = 0; c < cols; c++){\n                    const block = createBlock(c * GRID_BLOCK_SIZE + offsetX, r * GRID_BLOCK_SIZE + offsetY, c, r);\n                    blocksRef.current.push(block);\n                }\n            }\n            console.log(\"Grid created: \".concat(cols, \" \\xd7 \").concat(rows, \" = \").concat(blocksRef.current.length, \" blocks\"));\n        };\n        const handleMouseMove = (e)=>{\n            mouseRef.current.x = e.clientX;\n            mouseRef.current.y = e.clientY;\n            addHighlights();\n        };\n        const handleMouseOut = ()=>{\n            mouseRef.current.x = undefined;\n            mouseRef.current.y = undefined;\n        };\n        const addHighlights = ()=>{\n            const mouse = mouseRef.current;\n            if (mouse.x === undefined || mouse.y === undefined) return;\n            // Find closest block\n            let closestBlock = null;\n            let minDist = Infinity;\n            for (const block of blocksRef.current){\n                const dx = mouse.x - block.x;\n                const dy = mouse.y - block.y;\n                const dist = Math.sqrt(dx * dx + dy * dy);\n                if (dist < minDist) {\n                    minDist = dist;\n                    closestBlock = block;\n                }\n            }\n            if (!closestBlock || minDist > mouse.radius) return;\n            const now = Date.now();\n            // Highlight the closest block\n            closestBlock.element.style.borderColor = \"#ee6436\";\n            closestBlock.highlightEndTime = now + GRID_HIGHLIGHT_DURATION;\n            // Optional: Highlight neighboring blocks (cluster effect)\n            const clusterSize = Math.floor(Math.random() * 2) + 1;\n            let currentBlock = closestBlock;\n            const highlighted = [\n                closestBlock\n            ];\n            for(let i = 0; i < clusterSize; i++){\n                const neighbors = blocksRef.current.filter((nb)=>{\n                    if (highlighted.includes(nb)) return false;\n                    const dx = Math.abs(nb.gridX - currentBlock.gridX);\n                    const dy = Math.abs(nb.gridY - currentBlock.gridY);\n                    return dx <= 1 && dy <= 1;\n                });\n                if (neighbors.length === 0) break;\n                const randomNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];\n                randomNeighbor.element.style.borderColor = \"#ee6436\";\n                randomNeighbor.highlightEndTime = now + GRID_HIGHLIGHT_DURATION + i * 10;\n                highlighted.push(randomNeighbor);\n                currentBlock = randomNeighbor;\n            }\n        };\n        const animate = ()=>{\n            const now = Date.now();\n            blocksRef.current.forEach((block)=>{\n                if (block.highlightEndTime > 0 && now > block.highlightEndTime) {\n                    block.element.style.borderColor = \"#262626\";\n                    block.highlightEndTime = 0;\n                }\n            });\n            animationFrameRef.current = requestAnimationFrame(animate);\n        };\n        initGrid();\n        window.addEventListener(\"resize\", initGrid);\n        window.addEventListener(\"mousemove\", handleMouseMove);\n        window.addEventListener(\"mouseout\", handleMouseOut);\n        animationFrameRef.current = requestAnimationFrame(animate);\n        return ()=>{\n            window.removeEventListener(\"resize\", initGrid);\n            window.removeEventListener(\"mousemove\", handleMouseMove);\n            window.removeEventListener(\"mouseout\", handleMouseOut);\n            if (animationFrameRef.current) {\n                cancelAnimationFrame(animationFrameRef.current);\n            }\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"fixed top-0 left-0 w-full h-screen z-10 pointer-events-none overflow-hidden\",\n        style: {\n            backgroundColor: \"transparent\"\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\riyan\\\\Downloads\\\\copy-of-instaorbit-downloader (3)1\\\\src\\\\components\\\\client\\\\InteractiveGrid.tsx\",\n        lineNumber: 182,\n        columnNumber: 5\n    }, undefined);\n};\n_s(InteractiveGrid, \"teBVGi+FKRqoA3o49iipqAU8bFU=\");\n_c = InteractiveGrid;\nvar _c;\n$RefreshReg$(_c, \"InteractiveGrid\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2NsaWVudC9JbnRlcmFjdGl2ZUdyaWQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUVpRDtBQUVqRCxNQUFNRyxrQkFBa0I7QUFDeEIsTUFBTUMsMEJBQTBCO0FBV3pCLE1BQU1DLGtCQUE0Qjs7SUFDdkMsTUFBTUMsZUFBZUosNkNBQU1BLENBQWlCO0lBQzVDLE1BQU1LLFlBQVlMLDZDQUFNQSxDQUFjLEVBQUU7SUFDeEMsTUFBTU0sb0JBQW9CTiw2Q0FBTUE7SUFDaEMsTUFBTU8sV0FBV1AsNkNBQU1BLENBQW1FO1FBQ3hGUSxHQUFHQztRQUNIQyxHQUFHRDtRQUNIRSxRQUFRVixrQkFBa0I7SUFDNUI7SUFFQUYsZ0RBQVNBLENBQUM7UUFDUix5Q0FBeUM7UUFDekMsSUFBSSxLQUFrQixFQUFhLEVBQU87UUFFMUMsTUFBTWEsWUFBWVIsYUFBYVMsT0FBTztRQUN0QyxJQUFJLENBQUNELFdBQVc7UUFFaEIsTUFBTUUsY0FBYyxDQUFDQyxNQUFjQyxNQUFjQyxPQUFlQztZQUM5RCxNQUFNQyxLQUFLQyxTQUFTQyxhQUFhLENBQUM7WUFDbENGLEdBQUdHLFNBQVMsR0FBRztZQUNmSCxHQUFHSSxLQUFLLENBQUNDLE9BQU8sR0FBRyw4T0FRUHZCLE9BRERBLGlCQUFnQix5QkFFakJjLE9BREVkLGlCQUFnQix1QkFFbkJlLE9BRENELE1BQUssc0JBQ0QsT0FBTEMsTUFBSztZQUdkSixVQUFVYSxXQUFXLENBQUNOO1lBRXRCLE9BQU87Z0JBQ0xPLFNBQVNQO2dCQUNUWCxHQUFHTyxPQUFPZCxrQkFBa0I7Z0JBQzVCUyxHQUFHTSxPQUFPZixrQkFBa0I7Z0JBQzVCZ0I7Z0JBQ0FDO2dCQUNBUyxrQkFBa0I7WUFDcEI7UUFDRjtRQUVBLE1BQU1DLFdBQVc7WUFDZmhCLFVBQVVpQixTQUFTLEdBQUc7WUFDdEJ4QixVQUFVUSxPQUFPLEdBQUcsRUFBRTtZQUV0QixNQUFNaUIsUUFBUUMsT0FBT0MsVUFB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RSw4REFBQ3NFO1FBQ0NDLEtBQUtoRjtRQUNMa0IsV0FBVTtRQUNWQyxPQUFPO1lBQUU4RCxpQkFBaUI7UUFBYzs7Ozs7O0FBRzlDLEVBQUU7R0EzS1dsRjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9jbGllbnQvSW50ZXJhY3RpdmVHcmlkLnRzeD9jNDJmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuY29uc3QgR1JJRF9CTE9DS19TSVpFID0gNjA7XHJcbmNvbnN0IEdSSURfSElHSExJR0hUX0RVUkFUSU9OID0gMzAwO1xyXG5cclxuaW50ZXJmYWNlIEdyaWRCbG9jayB7XHJcbiAgZWxlbWVudDogSFRNTERpdkVsZW1lbnQ7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHk6IG51bWJlcjtcclxuICBncmlkWDogbnVtYmVyO1xyXG4gIGdyaWRZOiBudW1iZXI7XHJcbiAgaGlnaGxpZ2h0RW5kVGltZTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgSW50ZXJhY3RpdmVHcmlkOiBSZWFjdC5GQyA9ICgpID0+IHtcclxuICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xyXG4gIGNvbnN0IGJsb2Nrc1JlZiA9IHVzZVJlZjxHcmlkQmxvY2tbXT4oW10pO1xyXG4gIGNvbnN0IGFuaW1hdGlvbkZyYW1lUmVmID0gdXNlUmVmPG51bWJlcj4oKTtcclxuICBjb25zdCBtb3VzZVJlZiA9IHVzZVJlZjx7IHg6IG51bWJlciB8IHVuZGVmaW5lZDsgeTogbnVtYmVyIHwgdW5kZWZpbmVkOyByYWRpdXM6IG51bWJlciB9Pih7XHJcbiAgICB4OiB1bmRlZmluZWQsXHJcbiAgICB5OiB1bmRlZmluZWQsXHJcbiAgICByYWRpdXM6IEdSSURfQkxPQ0tfU0laRSAqIDIsXHJcbiAgfSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAvLyBTYWZldHkgY2hlY2sgZm9yIHNlcnZlci1zaWRlIHJlbmRlcmluZ1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGNyZWF0ZUJsb2NrID0gKHBvc1g6IG51bWJlciwgcG9zWTogbnVtYmVyLCBncmlkWDogbnVtYmVyLCBncmlkWTogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgIGVsLmNsYXNzTmFtZSA9ICdibG9jayc7XHJcbiAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSBgXHJcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xyXG4gICAgICAgIGJvcmRlcjogMC41cHggc29saWQgIzI2MjYyNjtcclxuICAgICAgICB0cmFuc2l0aW9uOiBib3JkZXItY29sb3IgMC4zcyBlYXNlO1xyXG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbiAgICAgICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcclxuICAgICAgICB3aWR0aDogJHtHUklEX0JMT0NLX1NJWkV9cHg7XHJcbiAgICAgICAgaGVpZ2h0OiAke0dSSURfQkxPQ0tfU0laRX1weDtcclxuICAgICAgICBsZWZ0OiAke3Bvc1h9cHg7XHJcbiAgICAgICAgdG9wOiAke3Bvc1l9cHg7XHJcbiAgICAgIGA7XHJcbiAgICAgIFxyXG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBlbGVtZW50OiBlbCxcclxuICAgICAgICB4OiBwb3NYICsgR1JJRF9CTE9DS19TSVpFIC8gMixcclxuICAgICAgICB5OiBwb3NZICsgR1JJRF9CTE9DS19TSVpFIC8gMixcclxuICAgICAgICBncmlkWCxcclxuICAgICAgICBncmlkWSxcclxuICAgICAgICBoaWdobGlnaHRFbmRUaW1lOiAwLFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBpbml0R3JpZCA9ICgpID0+IHtcclxuICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xyXG4gICAgICBibG9ja3NSZWYuY3VycmVudCA9IFtdO1xyXG5cclxuICAgICAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgY29uc3QgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xyXG5cclxuICAgICAgY29uc3QgY29scyA9IE1hdGguY2VpbCh3aWR0aCAvIEdSSURfQkxPQ0tfU0laRSk7XHJcbiAgICAgIGNvbnN0IHJvd3MgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gR1JJRF9CTE9DS19TSVpFKTtcclxuXHJcbiAgICAgIGNvbnN0IG9mZnNldFggPSAod2lkdGggLSBjb2xzICogR1JJRF9CTE9DS19TSVpFKSAvIDI7XHJcbiAgICAgIGNvbnN0IG9mZnNldFkgPSAoaGVpZ2h0IC0gcm93cyAqIEdSSURfQkxPQ0tfU0laRSkgLyAyO1xyXG5cclxuICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3dzOyByKyspIHtcclxuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvbHM7IGMrKykge1xyXG4gICAgICAgICAgY29uc3QgYmxvY2sgPSBjcmVhdGVCbG9jayhcclxuICAgICAgICAgICAgYyAqIEdSSURfQkxPQ0tfU0laRSArIG9mZnNldFgsXHJcbiAgICAgICAgICAgIHIgKiBHUklEX0JMT0NLX1NJWkUgKyBvZmZzZXRZLFxyXG4gICAgICAgICAgICBjLFxyXG4gICAgICAgICAgICByXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgYmxvY2tzUmVmLmN1cnJlbnQucHVzaChibG9jayk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhgR3JpZCBjcmVhdGVkOiAke2NvbHN9IMOXICR7cm93c30gPSAke2Jsb2Nrc1JlZi5jdXJyZW50Lmxlbmd0aH0gYmxvY2tzYCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZU1vdXNlTW92ZSA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgIG1vdXNlUmVmLmN1cnJlbnQueCA9IGUuY2xpZW50WDtcclxuICAgICAgbW91c2VSZWYuY3VycmVudC55ID0gZS5jbGllbnRZO1xyXG4gICAgICBhZGRIaWdobGlnaHRzKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZU1vdXNlT3V0ID0gKCkgPT4ge1xyXG4gICAgICBtb3VzZVJlZi5jdXJyZW50LnggPSB1bmRlZmluZWQ7XHJcbiAgICAgIG1vdXNlUmVmLmN1cnJlbnQueSA9IHVuZGVmaW5lZDtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgYWRkSGlnaGxpZ2h0cyA9ICgpID0+IHtcclxuICAgICAgY29uc3QgbW91c2UgPSBtb3VzZVJlZi5jdXJyZW50O1xyXG4gICAgICBpZiAobW91c2UueCA9PT0gdW5kZWZpbmVkIHx8IG1vdXNlLnkgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xyXG5cclxuICAgICAgLy8gRmluZCBjbG9zZXN0IGJsb2NrXHJcbiAgICAgIGxldCBjbG9zZXN0QmxvY2s6IEdyaWRCbG9jayB8IG51bGwgPSBudWxsO1xyXG4gICAgICBsZXQgbWluRGlzdCA9IEluZmluaXR5O1xyXG5cclxuICAgICAgZm9yIChjb25zdCBibG9jayBvZiBibG9ja3NSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNvbnN0IGR4ID0gbW91c2UueCAtIGJsb2NrLng7XHJcbiAgICAgICAgY29uc3QgZHkgPSBtb3VzZS55IC0gYmxvY2sueTtcclxuICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuXHJcbiAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XHJcbiAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcclxuICAgICAgICAgIGNsb3Nlc3RCbG9jayA9IGJsb2NrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFjbG9zZXN0QmxvY2sgfHwgbWluRGlzdCA+IG1vdXNlLnJhZGl1cykgcmV0dXJuO1xyXG5cclxuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEhpZ2hsaWdodCB0aGUgY2xvc2VzdCBibG9ja1xyXG4gICAgICBjbG9zZXN0QmxvY2suZWxlbWVudC5zdHlsZS5ib3JkZXJDb2xvciA9ICcjZWU2NDM2JztcclxuICAgICAgY2xvc2VzdEJsb2NrLmhpZ2hsaWdodEVuZFRpbWUgPSBub3cgKyBHUklEX0hJR0hMSUdIVF9EVVJBVElPTjtcclxuXHJcbiAgICAgIC8vIE9wdGlvbmFsOiBIaWdobGlnaHQgbmVpZ2hib3JpbmcgYmxvY2tzIChjbHVzdGVyIGVmZmVjdClcclxuICAgICAgY29uc3QgY2x1c3RlclNpemUgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyKSArIDE7XHJcbiAgICAgIGxldCBjdXJyZW50QmxvY2sgPSBjbG9zZXN0QmxvY2s7XHJcbiAgICAgIGNvbnN0IGhpZ2hsaWdodGVkID0gW2Nsb3Nlc3RCbG9ja107XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsdXN0ZXJTaXplOyBpKyspIHtcclxuICAgICAgICBjb25zdCBuZWlnaGJvcnMgPSBibG9ja3NSZWYuY3VycmVudC5maWx0ZXIoKG5iKSA9PiB7XHJcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWQuaW5jbHVkZXMobmIpKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgY29uc3QgZHggPSBNYXRoLmFicyhuYi5ncmlkWCAtIGN1cnJlbnRCbG9jay5ncmlkWCk7XHJcbiAgICAgICAgICBjb25zdCBkeSA9IE1hdGguYWJzKG5iLmdyaWRZIC0gY3VycmVudEJsb2NrLmdyaWRZKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gZHggPD0gMSAmJiBkeSA8PSAxO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAobmVpZ2hib3JzLmxlbmd0aCA9PT0gMCkgYnJlYWs7XHJcblxyXG4gICAgICAgIGNvbnN0IHJhbmRvbU5laWdoYm9yID0gbmVpZ2hib3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5laWdoYm9ycy5sZW5ndGgpXTtcclxuICAgICAgICByYW5kb21OZWlnaGJvci5lbGVtZW50LnN0eWxlLmJvcmRlckNvbG9yID0gJyNlZTY0MzYnO1xyXG4gICAgICAgIHJhbmRvbU5laWdoYm9yLmhpZ2hsaWdodEVuZFRpbWUgPSBub3cgKyBHUklEX0hJR0hMSUdIVF9EVVJBVElPTiArIGkgKiAxMDtcclxuXHJcbiAgICAgICAgaGlnaGxpZ2h0ZWQucHVzaChyYW5kb21OZWlnaGJvcik7XHJcbiAgICAgICAgY3VycmVudEJsb2NrID0gcmFuZG9tTmVpZ2hib3I7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcclxuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgYmxvY2tzUmVmLmN1cnJlbnQuZm9yRWFjaChibG9jayA9PiB7XHJcbiAgICAgICAgaWYgKGJsb2NrLmhpZ2hsaWdodEVuZFRpbWUgPiAwICYmIG5vdyA+IGJsb2NrLmhpZ2hsaWdodEVuZFRpbWUpIHtcclxuICAgICAgICAgIGJsb2NrLmVsZW1lbnQuc3R5bGUuYm9yZGVyQ29sb3IgPSAnIzI2MjYyNic7XHJcbiAgICAgICAgICBibG9jay5oaWdobGlnaHRFbmRUaW1lID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBhbmltYXRpb25GcmFtZVJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpbml0R3JpZCgpO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluaXRHcmlkKTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgaGFuZGxlTW91c2VPdXQpO1xyXG4gICAgYW5pbWF0aW9uRnJhbWVSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5pdEdyaWQpO1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgaGFuZGxlTW91c2VPdXQpO1xyXG4gICAgICBpZiAoYW5pbWF0aW9uRnJhbWVSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lUmVmLmN1cnJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgXHJcbiAgICAgIHJlZj17Y29udGFpbmVyUmVmfSBcclxuICAgICAgY2xhc3NOYW1lPVwiZml4ZWQgdG9wLTAgbGVmdC0wIHctZnVsbCBoLXNjcmVlbiB6LTEwIHBvaW50ZXItZXZlbnRzLW5vbmUgb3ZlcmZsb3ctaGlkZGVuXCJcclxuICAgICAgc3R5bGU9e3sgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnIH19XHJcbiAgICAvPlxyXG4gICk7XHJcbn07Il0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwiR1JJRF9CTE9DS19TSVpFIiwiR1JJRF9ISUdITElHSFRfRFVSQVRJT04iLCJJbnRlcmFjdGl2ZUdyaWQiLCJjb250YWluZXJSZWYiLCJibG9ja3NSZWYiLCJhbmltYXRpb25GcmFtZVJlZiIsIm1vdXNlUmVmIiwieCIsInVuZGVmaW5lZCIsInkiLCJyYWRpdXMiLCJjb250YWluZXIiLCJjdXJyZW50IiwiY3JlYXRlQmxvY2siLCJwb3NYIiwicG9zWSIsImdyaWRYIiwiZ3JpZFkiLCJlbCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsInN0eWxlIiwiY3NzVGV4dCIsImFwcGVuZENoaWxkIiwiZWxlbWVudCIsImhpZ2hsaWdodEVuZFRpbWUiLCJpbml0R3JpZCIsImlubmVySFRNTCIsIndpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImhlaWdodCIsImlubmVySGVpZ2h0IiwiY29scyIsIk1hdGgiLCJjZWlsIiwicm93cyIsIm9mZnNldFgiLCJvZmZzZXRZIiwiciIsImMiLCJibG9jayIsInB1c2giLCJjb25zb2xlIiwibG9nIiwibGVuZ3RoIiwiaGFuZGxlTW91c2VNb3ZlIiwiZSIsImNsaWVudFgiLCJjbGllbnRZIiwiYWRkSGlnaGxpZ2h0cyIsImhhbmRsZU1vdXNlT3V0IiwibW91c2UiLCJjbG9zZXN0QmxvY2siLCJtaW5EaXN0IiwiSW5maW5pdHkiLCJkeCIsImR5IiwiZGlzdCIsInNxcnQiLCJub3ciLCJEYXRlIiwiYm9yZGVyQ29sb3IiLCJjbHVzdGVyU2l6ZSIsImZsb29yIiwicmFuZG9tIiwiY3VycmVudEJsb2NrIiwiaGlnaGxpZ2h0ZWQiLCJpIiwibmVpZ2hib3JzIiwiZmlsdGVyIiwibmIiLCJpbmNsdWRlcyIsImFicyIsInJhbmRvbU5laWdoYm9yIiwiYW5pbWF0ZSIsImZvckVhY2giLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZGl2IiwicmVmIiwiYmFja2dyb3VuZENvbG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/client/InteractiveGrid.tsx\n"));

/***/ })

});