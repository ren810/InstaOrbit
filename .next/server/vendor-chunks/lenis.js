"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/lenis";
exports.ids = ["vendor-chunks/lenis"];
exports.modules = {

/***/ "(ssr)/./node_modules/lenis/dist/lenis.mjs":
/*!*******************************************!*\
  !*** ./node_modules/lenis/dist/lenis.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Lenis)\n/* harmony export */ });\n// package.json\nvar version = \"1.3.15\";\n// packages/core/src/maths.ts\nfunction clamp(min, input, max) {\n    return Math.max(min, Math.min(input, max));\n}\nfunction lerp(x, y, t) {\n    return (1 - t) * x + t * y;\n}\nfunction damp(x, y, lambda, deltaTime) {\n    return lerp(x, y, 1 - Math.exp(-lambda * deltaTime));\n}\nfunction modulo(n, d) {\n    return (n % d + d) % d;\n}\n// packages/core/src/animate.ts\nvar Animate = class {\n    /**\n   * Advance the animation by the given delta time\n   *\n   * @param deltaTime - The time in seconds to advance the animation\n   */ advance(deltaTime) {\n        if (!this.isRunning) return;\n        let completed = false;\n        if (this.duration && this.easing) {\n            this.currentTime += deltaTime;\n            const linearProgress = clamp(0, this.currentTime / this.duration, 1);\n            completed = linearProgress >= 1;\n            const easedProgress = completed ? 1 : this.easing(linearProgress);\n            this.value = this.from + (this.to - this.from) * easedProgress;\n        } else if (this.lerp) {\n            this.value = damp(this.value, this.to, this.lerp * 60, deltaTime);\n            if (Math.round(this.value) === this.to) {\n                this.value = this.to;\n                completed = true;\n            }\n        } else {\n            this.value = this.to;\n            completed = true;\n        }\n        if (completed) {\n            this.stop();\n        }\n        this.onUpdate?.(this.value, completed);\n    }\n    /** Stop the animation */ stop() {\n        this.isRunning = false;\n    }\n    /**\n   * Set up the animation from a starting value to an ending value\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\n   *\n   * @param from - The starting value\n   * @param to - The ending value\n   * @param options - Options for the animation\n   */ fromTo(from, to, { lerp: lerp2, duration, easing, onStart, onUpdate }) {\n        this.from = this.value = from;\n        this.to = to;\n        this.lerp = lerp2;\n        this.duration = duration;\n        this.easing = easing;\n        this.currentTime = 0;\n        this.isRunning = true;\n        onStart?.();\n        this.onUpdate = onUpdate;\n    }\n    constructor(){\n        this.isRunning = false;\n        this.value = 0;\n        this.from = 0;\n        this.to = 0;\n        this.currentTime = 0;\n    }\n};\n// packages/core/src/debounce.ts\nfunction debounce(callback, delay) {\n    let timer;\n    return function(...args) {\n        let context = this;\n        clearTimeout(timer);\n        timer = setTimeout(()=>{\n            timer = void 0;\n            callback.apply(context, args);\n        }, delay);\n    };\n}\n// packages/core/src/dimensions.ts\nvar Dimensions = class {\n    constructor(wrapper, content, { autoResize = true, debounce: debounceValue = 250 } = {}){\n        this.width = 0;\n        this.height = 0;\n        this.scrollHeight = 0;\n        this.scrollWidth = 0;\n        this.resize = ()=>{\n            this.onWrapperResize();\n            this.onContentResize();\n        };\n        this.onWrapperResize = ()=>{\n            if (this.wrapper instanceof Window) {\n                this.width = window.innerWidth;\n                this.height = window.innerHeight;\n            } else {\n                this.width = this.wrapper.clientWidth;\n                this.height = this.wrapper.clientHeight;\n            }\n        };\n        this.onContentResize = ()=>{\n            if (this.wrapper instanceof Window) {\n                this.scrollHeight = this.content.scrollHeight;\n                this.scrollWidth = this.content.scrollWidth;\n            } else {\n                this.scrollHeight = this.wrapper.scrollHeight;\n                this.scrollWidth = this.wrapper.scrollWidth;\n            }\n        };\n        this.wrapper = wrapper;\n        this.content = content;\n        if (autoResize) {\n            this.debouncedResize = debounce(this.resize, debounceValue);\n            if (this.wrapper instanceof Window) {\n                window.addEventListener(\"resize\", this.debouncedResize, false);\n            } else {\n                this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize);\n                this.wrapperResizeObserver.observe(this.wrapper);\n            }\n            this.contentResizeObserver = new ResizeObserver(this.debouncedResize);\n            this.contentResizeObserver.observe(this.content);\n        }\n        this.resize();\n    }\n    destroy() {\n        this.wrapperResizeObserver?.disconnect();\n        this.contentResizeObserver?.disconnect();\n        if (this.wrapper === window && this.debouncedResize) {\n            window.removeEventListener(\"resize\", this.debouncedResize, false);\n        }\n    }\n    get limit() {\n        return {\n            x: this.scrollWidth - this.width,\n            y: this.scrollHeight - this.height\n        };\n    }\n};\n// packages/core/src/emitter.ts\nvar Emitter = class {\n    /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */ emit(event, ...args) {\n        let callbacks = this.events[event] || [];\n        for(let i = 0, length = callbacks.length; i < length; i++){\n            callbacks[i]?.(...args);\n        }\n    }\n    /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */ on(event, cb) {\n        this.events[event]?.push(cb) || (this.events[event] = [\n            cb\n        ]);\n        return ()=>{\n            this.events[event] = this.events[event]?.filter((i)=>cb !== i);\n        };\n    }\n    /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */ off(event, callback) {\n        this.events[event] = this.events[event]?.filter((i)=>callback !== i);\n    }\n    /**\n   * Remove all event listeners and clean up\n   */ destroy() {\n        this.events = {};\n    }\n    constructor(){\n        this.events = {};\n    }\n};\n// packages/core/src/virtual-scroll.ts\nvar LINE_HEIGHT = 100 / 6;\nvar listenerOptions = {\n    passive: false\n};\nvar VirtualScroll = class {\n    constructor(element, options = {\n        wheelMultiplier: 1,\n        touchMultiplier: 1\n    }){\n        this.touchStart = {\n            x: 0,\n            y: 0\n        };\n        this.lastDelta = {\n            x: 0,\n            y: 0\n        };\n        this.window = {\n            width: 0,\n            height: 0\n        };\n        this.emitter = new Emitter();\n        /**\n   * Event handler for 'touchstart' event\n   *\n   * @param event Touch event\n   */ this.onTouchStart = (event)=>{\n            const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n            this.touchStart.x = clientX;\n            this.touchStart.y = clientY;\n            this.lastDelta = {\n                x: 0,\n                y: 0\n            };\n            this.emitter.emit(\"scroll\", {\n                deltaX: 0,\n                deltaY: 0,\n                event\n            });\n        };\n        /** Event handler for 'touchmove' event */ this.onTouchMove = (event)=>{\n            const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n            const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier;\n            const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier;\n            this.touchStart.x = clientX;\n            this.touchStart.y = clientY;\n            this.lastDelta = {\n                x: deltaX,\n                y: deltaY\n            };\n            this.emitter.emit(\"scroll\", {\n                deltaX,\n                deltaY,\n                event\n            });\n        };\n        this.onTouchEnd = (event)=>{\n            this.emitter.emit(\"scroll\", {\n                deltaX: this.lastDelta.x,\n                deltaY: this.lastDelta.y,\n                event\n            });\n        };\n        /** Event handler for 'wheel' event */ this.onWheel = (event)=>{\n            let { deltaX, deltaY, deltaMode } = event;\n            const multiplierX = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1;\n            const multiplierY = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1;\n            deltaX *= multiplierX;\n            deltaY *= multiplierY;\n            deltaX *= this.options.wheelMultiplier;\n            deltaY *= this.options.wheelMultiplier;\n            this.emitter.emit(\"scroll\", {\n                deltaX,\n                deltaY,\n                event\n            });\n        };\n        this.onWindowResize = ()=>{\n            this.window = {\n                width: window.innerWidth,\n                height: window.innerHeight\n            };\n        };\n        this.element = element;\n        this.options = options;\n        window.addEventListener(\"resize\", this.onWindowResize, false);\n        this.onWindowResize();\n        this.element.addEventListener(\"wheel\", this.onWheel, listenerOptions);\n        this.element.addEventListener(\"touchstart\", this.onTouchStart, listenerOptions);\n        this.element.addEventListener(\"touchmove\", this.onTouchMove, listenerOptions);\n        this.element.addEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n    }\n    /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */ on(event, callback) {\n        return this.emitter.on(event, callback);\n    }\n    /** Remove all event listeners and clean up */ destroy() {\n        this.emitter.destroy();\n        window.removeEventListener(\"resize\", this.onWindowResize, false);\n        this.element.removeEventListener(\"wheel\", this.onWheel, listenerOptions);\n        this.element.removeEventListener(\"touchstart\", this.onTouchStart, listenerOptions);\n        this.element.removeEventListener(\"touchmove\", this.onTouchMove, listenerOptions);\n        this.element.removeEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n    }\n};\n// packages/core/src/lenis.ts\nvar defaultEasing = (t)=>Math.min(1, 1.001 - Math.pow(2, -10 * t));\nvar Lenis = class {\n    constructor({ wrapper = window, content = document.documentElement, eventsTarget = wrapper, smoothWheel = true, syncTouch = false, syncTouchLerp = 0.075, touchInertiaExponent = 1.7, duration, // in seconds\n    easing, lerp: lerp2 = 0.1, infinite = false, orientation = \"vertical\", // vertical, horizontal\n    gestureOrientation = orientation === \"horizontal\" ? \"both\" : \"vertical\", // vertical, horizontal, both\n    touchMultiplier = 1, wheelMultiplier = 1, autoResize = true, prevent, virtualScroll, overscroll = true, autoRaf = false, anchors = false, autoToggle = false, // https://caniuse.com/?search=transition-behavior\n    allowNestedScroll = false, __experimental__naiveDimensions = false } = {}){\n        this._isScrolling = false;\n        // true when scroll is animating\n        this._isStopped = false;\n        // true if user should not be able to scroll - enable/disable programmatically\n        this._isLocked = false;\n        // same as isStopped but enabled/disabled when scroll reaches target\n        this._preventNextNativeScrollEvent = false;\n        this._resetVelocityTimeout = null;\n        this.__rafID = null;\n        /**\n   * The time in ms since the lenis instance was created\n   */ this.time = 0;\n        /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */ this.userData = {};\n        /**\n   * The last velocity of the scroll\n   */ this.lastVelocity = 0;\n        /**\n   * The current velocity of the scroll\n   */ this.velocity = 0;\n        /**\n   * The direction of the scroll\n   */ this.direction = 0;\n        // These are instanciated here as they don't need information from the options\n        this.animate = new Animate();\n        this.emitter = new Emitter();\n        this.onScrollEnd = (e)=>{\n            if (!(e instanceof CustomEvent)) {\n                if (this.isScrolling === \"smooth\" || this.isScrolling === false) {\n                    e.stopPropagation();\n                }\n            }\n        };\n        this.dispatchScrollendEvent = ()=>{\n            this.options.wrapper.dispatchEvent(new CustomEvent(\"scrollend\", {\n                bubbles: this.options.wrapper === window,\n                // cancelable: false,\n                detail: {\n                    lenisScrollEnd: true\n                }\n            }));\n        };\n        this.onTransitionEnd = (event)=>{\n            if (event.propertyName.includes(\"overflow\")) {\n                const property = this.isHorizontal ? \"overflow-x\" : \"overflow-y\";\n                const overflow = getComputedStyle(this.rootElement)[property];\n                if ([\n                    \"hidden\",\n                    \"clip\"\n                ].includes(overflow)) {\n                    this.internalStop();\n                } else {\n                    this.internalStart();\n                }\n            }\n        };\n        this.onClick = (event)=>{\n            const path = event.composedPath();\n            const anchor = path.find((node)=>node instanceof HTMLAnchorElement && node.getAttribute(\"href\")?.includes(\"#\"));\n            if (anchor) {\n                const href = anchor.getAttribute(\"href\");\n                if (href) {\n                    const options = typeof this.options.anchors === \"object\" && this.options.anchors ? this.options.anchors : void 0;\n                    const target = `#${href.split(\"#\")[1]}`;\n                    this.scrollTo(target, options);\n                }\n            }\n        };\n        this.onPointerDown = (event)=>{\n            if (event.button === 1) {\n                this.reset();\n            }\n        };\n        this.onVirtualScroll = (data)=>{\n            if (typeof this.options.virtualScroll === \"function\" && this.options.virtualScroll(data) === false) return;\n            const { deltaX, deltaY, event } = data;\n            this.emitter.emit(\"virtual-scroll\", {\n                deltaX,\n                deltaY,\n                event\n            });\n            if (event.ctrlKey) return;\n            if (event.lenisStopPropagation) return;\n            const isTouch = event.type.includes(\"touch\");\n            const isWheel = event.type.includes(\"wheel\");\n            this.isTouching = event.type === \"touchstart\" || event.type === \"touchmove\";\n            const isClickOrTap = deltaX === 0 && deltaY === 0;\n            const isTapToStop = this.options.syncTouch && isTouch && event.type === \"touchstart\" && isClickOrTap && !this.isStopped && !this.isLocked;\n            if (isTapToStop) {\n                this.reset();\n                return;\n            }\n            const isUnknownGesture = this.options.gestureOrientation === \"vertical\" && deltaY === 0 || this.options.gestureOrientation === \"horizontal\" && deltaX === 0;\n            if (isClickOrTap || isUnknownGesture) {\n                return;\n            }\n            let composedPath = event.composedPath();\n            composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement));\n            const prevent = this.options.prevent;\n            if (!!composedPath.find((node)=>node instanceof HTMLElement && (typeof prevent === \"function\" && prevent?.(node) || node.hasAttribute?.(\"data-lenis-prevent\") || isTouch && node.hasAttribute?.(\"data-lenis-prevent-touch\") || isWheel && node.hasAttribute?.(\"data-lenis-prevent-wheel\") || this.options.allowNestedScroll && this.checkNestedScroll(node, {\n                    deltaX,\n                    deltaY\n                })))) return;\n            if (this.isStopped || this.isLocked) {\n                if (event.cancelable) {\n                    event.preventDefault();\n                }\n                return;\n            }\n            const isSmooth = this.options.syncTouch && isTouch || this.options.smoothWheel && isWheel;\n            if (!isSmooth) {\n                this.isScrolling = \"native\";\n                this.animate.stop();\n                event.lenisStopPropagation = true;\n                return;\n            }\n            let delta = deltaY;\n            if (this.options.gestureOrientation === \"both\") {\n                delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;\n            } else if (this.options.gestureOrientation === \"horizontal\") {\n                delta = deltaX;\n            }\n            if (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && this.limit > 0 && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && deltaY > 0 || this.animatedScroll === this.limit && deltaY < 0)) {\n                event.lenisStopPropagation = true;\n            }\n            if (event.cancelable) {\n                event.preventDefault();\n            }\n            const isSyncTouch = isTouch && this.options.syncTouch;\n            const isTouchEnd = isTouch && event.type === \"touchend\";\n            const hasTouchInertia = isTouchEnd;\n            if (hasTouchInertia) {\n                delta = Math.sign(this.velocity) * Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent);\n            }\n            this.scrollTo(this.targetScroll + delta, {\n                programmatic: false,\n                ...isSyncTouch ? {\n                    lerp: hasTouchInertia ? this.options.syncTouchLerp : 1\n                } : {\n                    lerp: this.options.lerp,\n                    duration: this.options.duration,\n                    easing: this.options.easing\n                }\n            });\n        };\n        this.onNativeScroll = ()=>{\n            if (this._resetVelocityTimeout !== null) {\n                clearTimeout(this._resetVelocityTimeout);\n                this._resetVelocityTimeout = null;\n            }\n            if (this._preventNextNativeScrollEvent) {\n                this._preventNextNativeScrollEvent = false;\n                return;\n            }\n            if (this.isScrolling === false || this.isScrolling === \"native\") {\n                const lastScroll = this.animatedScroll;\n                this.animatedScroll = this.targetScroll = this.actualScroll;\n                this.lastVelocity = this.velocity;\n                this.velocity = this.animatedScroll - lastScroll;\n                this.direction = Math.sign(this.animatedScroll - lastScroll);\n                if (!this.isStopped) {\n                    this.isScrolling = \"native\";\n                }\n                this.emit();\n                if (this.velocity !== 0) {\n                    this._resetVelocityTimeout = setTimeout(()=>{\n                        this.lastVelocity = this.velocity;\n                        this.velocity = 0;\n                        this.isScrolling = false;\n                        this.emit();\n                    }, 400);\n                }\n            }\n        };\n        /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */ this.raf = (time)=>{\n            const deltaTime = time - (this.time || time);\n            this.time = time;\n            this.animate.advance(deltaTime * 1e-3);\n            if (this.options.autoRaf) {\n                this.__rafID = requestAnimationFrame(this.raf);\n            }\n        };\n        window.lenisVersion = version;\n        if (!wrapper || wrapper === document.documentElement) {\n            wrapper = window;\n        }\n        if (typeof duration === \"number\" && typeof easing !== \"function\") {\n            easing = defaultEasing;\n        } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n            duration = 1;\n        }\n        this.options = {\n            wrapper,\n            content,\n            eventsTarget,\n            smoothWheel,\n            syncTouch,\n            syncTouchLerp,\n            touchInertiaExponent,\n            duration,\n            easing,\n            lerp: lerp2,\n            infinite,\n            gestureOrientation,\n            orientation,\n            touchMultiplier,\n            wheelMultiplier,\n            autoResize,\n            prevent,\n            virtualScroll,\n            overscroll,\n            autoRaf,\n            anchors,\n            autoToggle,\n            allowNestedScroll,\n            __experimental__naiveDimensions\n        };\n        this.dimensions = new Dimensions(wrapper, content, {\n            autoResize\n        });\n        this.updateClassName();\n        this.targetScroll = this.animatedScroll = this.actualScroll;\n        this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, false);\n        this.options.wrapper.addEventListener(\"scrollend\", this.onScrollEnd, {\n            capture: true\n        });\n        if (this.options.anchors && this.options.wrapper === window) {\n            this.options.wrapper.addEventListener(\"click\", this.onClick, false);\n        }\n        this.options.wrapper.addEventListener(\"pointerdown\", this.onPointerDown, false);\n        this.virtualScroll = new VirtualScroll(eventsTarget, {\n            touchMultiplier,\n            wheelMultiplier\n        });\n        this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n        if (this.options.autoToggle) {\n            this.rootElement.addEventListener(\"transitionend\", this.onTransitionEnd, {\n                passive: true\n            });\n        }\n        if (this.options.autoRaf) {\n            this.__rafID = requestAnimationFrame(this.raf);\n        }\n    }\n    /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */ destroy() {\n        this.emitter.destroy();\n        this.options.wrapper.removeEventListener(\"scroll\", this.onNativeScroll, false);\n        this.options.wrapper.removeEventListener(\"scrollend\", this.onScrollEnd, {\n            capture: true\n        });\n        this.options.wrapper.removeEventListener(\"pointerdown\", this.onPointerDown, false);\n        if (this.options.anchors && this.options.wrapper === window) {\n            this.options.wrapper.removeEventListener(\"click\", this.onClick, false);\n        }\n        this.virtualScroll.destroy();\n        this.dimensions.destroy();\n        this.cleanUpClassName();\n        if (this.__rafID) {\n            cancelAnimationFrame(this.__rafID);\n        }\n    }\n    on(event, callback) {\n        return this.emitter.on(event, callback);\n    }\n    off(event, callback) {\n        return this.emitter.off(event, callback);\n    }\n    setScroll(scroll) {\n        if (this.isHorizontal) {\n            this.options.wrapper.scrollTo({\n                left: scroll,\n                behavior: \"instant\"\n            });\n        } else {\n            this.options.wrapper.scrollTo({\n                top: scroll,\n                behavior: \"instant\"\n            });\n        }\n    }\n    /**\n   * Force lenis to recalculate the dimensions\n   */ resize() {\n        this.dimensions.resize();\n        this.animatedScroll = this.targetScroll = this.actualScroll;\n        this.emit();\n    }\n    emit() {\n        this.emitter.emit(\"scroll\", this);\n    }\n    reset() {\n        this.isLocked = false;\n        this.isScrolling = false;\n        this.animatedScroll = this.targetScroll = this.actualScroll;\n        this.lastVelocity = this.velocity = 0;\n        this.animate.stop();\n    }\n    /**\n   * Start lenis scroll after it has been stopped\n   */ start() {\n        if (!this.isStopped) return;\n        if (this.options.autoToggle) {\n            this.rootElement.style.removeProperty(\"overflow\");\n            return;\n        }\n        this.internalStart();\n    }\n    internalStart() {\n        if (!this.isStopped) return;\n        this.reset();\n        this.isStopped = false;\n        this.emit();\n    }\n    /**\n   * Stop lenis scroll\n   */ stop() {\n        if (this.isStopped) return;\n        if (this.options.autoToggle) {\n            this.rootElement.style.setProperty(\"overflow\", \"clip\");\n            return;\n        }\n        this.internalStop();\n    }\n    internalStop() {\n        if (this.isStopped) return;\n        this.reset();\n        this.isStopped = true;\n        this.emit();\n    }\n    /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */ scrollTo(target, { offset = 0, immediate = false, lock = false, duration = this.options.duration, easing = this.options.easing, lerp: lerp2 = this.options.lerp, onStart, onComplete, force = false, // scroll even if stopped\n    programmatic = true, // called from outside of the class\n    userData } = {}) {\n        if ((this.isStopped || this.isLocked) && !force) return;\n        if (typeof target === \"string\" && [\n            \"top\",\n            \"left\",\n            \"start\",\n            \"#\"\n        ].includes(target)) {\n            target = 0;\n        } else if (typeof target === \"string\" && [\n            \"bottom\",\n            \"right\",\n            \"end\"\n        ].includes(target)) {\n            target = this.limit;\n        } else {\n            let node;\n            if (typeof target === \"string\") {\n                node = document.querySelector(target);\n                if (!node) {\n                    if (target === \"#top\") {\n                        target = 0;\n                    } else {\n                        console.warn(\"Lenis: Target not found\", target);\n                    }\n                }\n            } else if (target instanceof HTMLElement && target?.nodeType) {\n                node = target;\n            }\n            if (node) {\n                if (this.options.wrapper !== window) {\n                    const wrapperRect = this.rootElement.getBoundingClientRect();\n                    offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;\n                }\n                const rect = node.getBoundingClientRect();\n                target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;\n            }\n        }\n        if (typeof target !== \"number\") return;\n        target += offset;\n        target = Math.round(target);\n        if (this.options.infinite) {\n            if (programmatic) {\n                this.targetScroll = this.animatedScroll = this.scroll;\n                const distance = target - this.animatedScroll;\n                if (distance > this.limit / 2) {\n                    target = target - this.limit;\n                } else if (distance < -this.limit / 2) {\n                    target = target + this.limit;\n                }\n            }\n        } else {\n            target = clamp(0, target, this.limit);\n        }\n        if (target === this.targetScroll) {\n            onStart?.(this);\n            onComplete?.(this);\n            return;\n        }\n        this.userData = userData ?? {};\n        if (immediate) {\n            this.animatedScroll = this.targetScroll = target;\n            this.setScroll(this.scroll);\n            this.reset();\n            this.preventNextNativeScrollEvent();\n            this.emit();\n            onComplete?.(this);\n            this.userData = {};\n            requestAnimationFrame(()=>{\n                this.dispatchScrollendEvent();\n            });\n            return;\n        }\n        if (!programmatic) {\n            this.targetScroll = target;\n        }\n        if (typeof duration === \"number\" && typeof easing !== \"function\") {\n            easing = defaultEasing;\n        } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n            duration = 1;\n        }\n        this.animate.fromTo(this.animatedScroll, target, {\n            duration,\n            easing,\n            lerp: lerp2,\n            onStart: ()=>{\n                if (lock) this.isLocked = true;\n                this.isScrolling = \"smooth\";\n                onStart?.(this);\n            },\n            onUpdate: (value, completed)=>{\n                this.isScrolling = \"smooth\";\n                this.lastVelocity = this.velocity;\n                this.velocity = value - this.animatedScroll;\n                this.direction = Math.sign(this.velocity);\n                this.animatedScroll = value;\n                this.setScroll(this.scroll);\n                if (programmatic) {\n                    this.targetScroll = value;\n                }\n                if (!completed) this.emit();\n                if (completed) {\n                    this.reset();\n                    this.emit();\n                    onComplete?.(this);\n                    this.userData = {};\n                    requestAnimationFrame(()=>{\n                        this.dispatchScrollendEvent();\n                    });\n                    this.preventNextNativeScrollEvent();\n                }\n            }\n        });\n    }\n    preventNextNativeScrollEvent() {\n        this._preventNextNativeScrollEvent = true;\n        requestAnimationFrame(()=>{\n            this._preventNextNativeScrollEvent = false;\n        });\n    }\n    checkNestedScroll(node, { deltaX, deltaY }) {\n        const time = Date.now();\n        const cache = node._lenis ??= {};\n        let hasOverflowX, hasOverflowY, isScrollableX, isScrollableY, scrollWidth, scrollHeight, clientWidth, clientHeight;\n        const gestureOrientation = this.options.gestureOrientation;\n        if (time - (cache.time ?? 0) > 2e3) {\n            cache.time = Date.now();\n            const computedStyle = window.getComputedStyle(node);\n            cache.computedStyle = computedStyle;\n            const overflowXString = computedStyle.overflowX;\n            const overflowYString = computedStyle.overflowY;\n            hasOverflowX = [\n                \"auto\",\n                \"overlay\",\n                \"scroll\"\n            ].includes(overflowXString);\n            hasOverflowY = [\n                \"auto\",\n                \"overlay\",\n                \"scroll\"\n            ].includes(overflowYString);\n            cache.hasOverflowX = hasOverflowX;\n            cache.hasOverflowY = hasOverflowY;\n            if (!hasOverflowX && !hasOverflowY) return false;\n            if (gestureOrientation === \"vertical\" && !hasOverflowY) return false;\n            if (gestureOrientation === \"horizontal\" && !hasOverflowX) return false;\n            scrollWidth = node.scrollWidth;\n            scrollHeight = node.scrollHeight;\n            clientWidth = node.clientWidth;\n            clientHeight = node.clientHeight;\n            isScrollableX = scrollWidth > clientWidth;\n            isScrollableY = scrollHeight > clientHeight;\n            cache.isScrollableX = isScrollableX;\n            cache.isScrollableY = isScrollableY;\n            cache.scrollWidth = scrollWidth;\n            cache.scrollHeight = scrollHeight;\n            cache.clientWidth = clientWidth;\n            cache.clientHeight = clientHeight;\n        } else {\n            isScrollableX = cache.isScrollableX;\n            isScrollableY = cache.isScrollableY;\n            hasOverflowX = cache.hasOverflowX;\n            hasOverflowY = cache.hasOverflowY;\n            scrollWidth = cache.scrollWidth;\n            scrollHeight = cache.scrollHeight;\n            clientWidth = cache.clientWidth;\n            clientHeight = cache.clientHeight;\n        }\n        if (!hasOverflowX && !hasOverflowY || !isScrollableX && !isScrollableY) {\n            return false;\n        }\n        if (gestureOrientation === \"vertical\" && (!hasOverflowY || !isScrollableY)) return false;\n        if (gestureOrientation === \"horizontal\" && (!hasOverflowX || !isScrollableX)) return false;\n        let orientation;\n        if (gestureOrientation === \"horizontal\") {\n            orientation = \"x\";\n        } else if (gestureOrientation === \"vertical\") {\n            orientation = \"y\";\n        } else {\n            const isScrollingX = deltaX !== 0;\n            const isScrollingY = deltaY !== 0;\n            if (isScrollingX && hasOverflowX && isScrollableX) {\n                orientation = \"x\";\n            }\n            if (isScrollingY && hasOverflowY && isScrollableY) {\n                orientation = \"y\";\n            }\n        }\n        if (!orientation) return false;\n        let scroll, maxScroll, delta, hasOverflow, isScrollable;\n        if (orientation === \"x\") {\n            scroll = node.scrollLeft;\n            maxScroll = scrollWidth - clientWidth;\n            delta = deltaX;\n            hasOverflow = hasOverflowX;\n            isScrollable = isScrollableX;\n        } else if (orientation === \"y\") {\n            scroll = node.scrollTop;\n            maxScroll = scrollHeight - clientHeight;\n            delta = deltaY;\n            hasOverflow = hasOverflowY;\n            isScrollable = isScrollableY;\n        } else {\n            return false;\n        }\n        const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0;\n        return willScroll && hasOverflow && isScrollable;\n    }\n    /**\n   * The root element on which lenis is instanced\n   */ get rootElement() {\n        return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n    }\n    /**\n   * The limit which is the maximum scroll value\n   */ get limit() {\n        if (this.options.__experimental__naiveDimensions) {\n            if (this.isHorizontal) {\n                return this.rootElement.scrollWidth - this.rootElement.clientWidth;\n            } else {\n                return this.rootElement.scrollHeight - this.rootElement.clientHeight;\n            }\n        } else {\n            return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n        }\n    }\n    /**\n   * Whether or not the scroll is horizontal\n   */ get isHorizontal() {\n        return this.options.orientation === \"horizontal\";\n    }\n    /**\n   * The actual scroll value\n   */ get actualScroll() {\n        const wrapper = this.options.wrapper;\n        return this.isHorizontal ? wrapper.scrollX ?? wrapper.scrollLeft : wrapper.scrollY ?? wrapper.scrollTop;\n    }\n    /**\n   * The current scroll value\n   */ get scroll() {\n        return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll;\n    }\n    /**\n   * The progress of the scroll relative to the limit\n   */ get progress() {\n        return this.limit === 0 ? 1 : this.scroll / this.limit;\n    }\n    /**\n   * Current scroll state\n   */ get isScrolling() {\n        return this._isScrolling;\n    }\n    set isScrolling(value) {\n        if (this._isScrolling !== value) {\n            this._isScrolling = value;\n            this.updateClassName();\n        }\n    }\n    /**\n   * Check if lenis is stopped\n   */ get isStopped() {\n        return this._isStopped;\n    }\n    set isStopped(value) {\n        if (this._isStopped !== value) {\n            this._isStopped = value;\n            this.updateClassName();\n        }\n    }\n    /**\n   * Check if lenis is locked\n   */ get isLocked() {\n        return this._isLocked;\n    }\n    set isLocked(value) {\n        if (this._isLocked !== value) {\n            this._isLocked = value;\n            this.updateClassName();\n        }\n    }\n    /**\n   * Check if lenis is smooth scrolling\n   */ get isSmooth() {\n        return this.isScrolling === \"smooth\";\n    }\n    /**\n   * The class name applied to the wrapper element\n   */ get className() {\n        let className = \"lenis\";\n        if (this.options.autoToggle) className += \" lenis-autoToggle\";\n        if (this.isStopped) className += \" lenis-stopped\";\n        if (this.isLocked) className += \" lenis-locked\";\n        if (this.isScrolling) className += \" lenis-scrolling\";\n        if (this.isScrolling === \"smooth\") className += \" lenis-smooth\";\n        return className;\n    }\n    updateClassName() {\n        this.cleanUpClassName();\n        this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();\n    }\n    cleanUpClassName() {\n        this.rootElement.className = this.rootElement.className.replace(/lenis(-\\w+)?/g, \"\").trim();\n    }\n};\n //# sourceMappingURL=lenis.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFLElBQUksQ0FBQ0EsU0FBUyxDQUFDLENBQUMsQ0FBQ0MsSUFBSTtJQUNyRjtJQUNBbEQsbUJBQW1CO1FBQ2pCLElBQUksQ0FBQ3pELFdBQVcsQ0FBQzBHLFNBQVMsR0FBRyxJQUFJLENBQUMxRyxXQUFXLENBQUMwRyxTQUFTLENBQUNFLE9BQU8sQ0FBQyxpQkFBaUIsSUFBSUQsSUFBSTtJQUMzRjtBQUNGO0FBR0UsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0YS1vcmJpdC1kb3dubG9hZGVyLy4vbm9kZV9tb2R1bGVzL2xlbmlzL2Rpc3QvbGVuaXMubWpzPzEyODMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcGFja2FnZS5qc29uXG52YXIgdmVyc2lvbiA9IFwiMS4zLjE1XCI7XG5cbi8vIHBhY2thZ2VzL2NvcmUvc3JjL21hdGhzLnRzXG5mdW5jdGlvbiBjbGFtcChtaW4sIGlucHV0LCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4oaW5wdXQsIG1heCkpO1xufVxuZnVuY3Rpb24gbGVycCh4LCB5LCB0KSB7XG4gIHJldHVybiAoMSAtIHQpICogeCArIHQgKiB5O1xufVxuZnVuY3Rpb24gZGFtcCh4LCB5LCBsYW1iZGEsIGRlbHRhVGltZSkge1xuICByZXR1cm4gbGVycCh4LCB5LCAxIC0gTWF0aC5leHAoLWxhbWJkYSAqIGRlbHRhVGltZSkpO1xufVxuZnVuY3Rpb24gbW9kdWxvKG4sIGQpIHtcbiAgcmV0dXJuIChuICUgZCArIGQpICUgZDtcbn1cblxuLy8gcGFja2FnZXMvY29yZS9zcmMvYW5pbWF0ZS50c1xudmFyIEFuaW1hdGUgPSBjbGFzcyB7XG4gIGlzUnVubmluZyA9IGZhbHNlO1xuICB2YWx1ZSA9IDA7XG4gIGZyb20gPSAwO1xuICB0byA9IDA7XG4gIGN1cnJlbnRUaW1lID0gMDtcbiAgLy8gVGhlc2UgYXJlIGluc3RhbmNpYXRlZCBpbiB0aGUgZnJvbVRvIG1ldGhvZFxuICBsZXJwO1xuICBkdXJhdGlvbjtcbiAgZWFzaW5nO1xuICBvblVwZGF0ZTtcbiAgLyoqXG4gICAqIEFkdmFuY2UgdGhlIGFuaW1hdGlvbiBieSB0aGUgZ2l2ZW4gZGVsdGEgdGltZVxuICAgKlxuICAgKiBAcGFyYW0gZGVsdGFUaW1lIC0gVGhlIHRpbWUgaW4gc2Vjb25kcyB0byBhZHZhbmNlIHRoZSBhbmltYXRpb25cbiAgICovXG4gIGFkdmFuY2UoZGVsdGFUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykgcmV0dXJuO1xuICAgIGxldCBjb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5kdXJhdGlvbiAmJiB0aGlzLmVhc2luZykge1xuICAgICAgdGhpcy5jdXJyZW50VGltZSArPSBkZWx0YVRpbWU7XG4gICAgICBjb25zdCBsaW5lYXJQcm9ncmVzcyA9IGNsYW1wKDAsIHRoaXMuY3VycmVudFRpbWUgLyB0aGlzLmR1cmF0aW9uLCAxKTtcbiAgICAgIGNvbXBsZXRlZCA9IGxpbmVhclByb2dyZXNzID49IDE7XG4gICAgICBjb25zdCBlYXNlZFByb2dyZXNzID0gY29tcGxldGVkID8gMSA6IHRoaXMuZWFzaW5nKGxpbmVhclByb2dyZXNzKTtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmZyb20gKyAodGhpcy50byAtIHRoaXMuZnJvbSkgKiBlYXNlZFByb2dyZXNzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZXJwKSB7XG4gICAgICB0aGlzLnZhbHVlID0gZGFtcCh0aGlzLnZhbHVlLCB0aGlzLnRvLCB0aGlzLmxlcnAgKiA2MCwgZGVsdGFUaW1lKTtcbiAgICAgIGlmIChNYXRoLnJvdW5kKHRoaXMudmFsdWUpID09PSB0aGlzLnRvKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnRvO1xuICAgICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy50bztcbiAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cbiAgICB0aGlzLm9uVXBkYXRlPy4odGhpcy52YWx1ZSwgY29tcGxldGVkKTtcbiAgfVxuICAvKiogU3RvcCB0aGUgYW5pbWF0aW9uICovXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogU2V0IHVwIHRoZSBhbmltYXRpb24gZnJvbSBhIHN0YXJ0aW5nIHZhbHVlIHRvIGFuIGVuZGluZyB2YWx1ZVxuICAgKiB3aXRoIG9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIGxlcnBpbmcsIGR1cmF0aW9uLCBlYXNpbmcsIGFuZCBvblVwZGF0ZSBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSBzdGFydGluZyB2YWx1ZVxuICAgKiBAcGFyYW0gdG8gLSBUaGUgZW5kaW5nIHZhbHVlXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGFuaW1hdGlvblxuICAgKi9cbiAgZnJvbVRvKGZyb20sIHRvLCB7IGxlcnA6IGxlcnAyLCBkdXJhdGlvbiwgZWFzaW5nLCBvblN0YXJ0LCBvblVwZGF0ZSB9KSB7XG4gICAgdGhpcy5mcm9tID0gdGhpcy52YWx1ZSA9IGZyb207XG4gICAgdGhpcy50byA9IHRvO1xuICAgIHRoaXMubGVycCA9IGxlcnAyO1xuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB0aGlzLmVhc2luZyA9IGVhc2luZztcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgb25TdGFydD8uKCk7XG4gICAgdGhpcy5vblVwZGF0ZSA9IG9uVXBkYXRlO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9jb3JlL3NyYy9kZWJvdW5jZS50c1xuZnVuY3Rpb24gZGVib3VuY2UoY2FsbGJhY2ssIGRlbGF5KSB7XG4gIGxldCB0aW1lcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBsZXQgY29udGV4dCA9IHRoaXM7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGltZXIgPSB2b2lkIDA7XG4gICAgICBjYWxsYmFjay5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9LCBkZWxheSk7XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2NvcmUvc3JjL2RpbWVuc2lvbnMudHNcbnZhciBEaW1lbnNpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih3cmFwcGVyLCBjb250ZW50LCB7IGF1dG9SZXNpemUgPSB0cnVlLCBkZWJvdW5jZTogZGVib3VuY2VWYWx1ZSA9IDI1MCB9ID0ge30pIHtcbiAgICB0aGlzLndyYXBwZXIgPSB3cmFwcGVyO1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgaWYgKGF1dG9SZXNpemUpIHtcbiAgICAgIHRoaXMuZGVib3VuY2VkUmVzaXplID0gZGVib3VuY2UodGhpcy5yZXNpemUsIGRlYm91bmNlVmFsdWUpO1xuICAgICAgaWYgKHRoaXMud3JhcHBlciBpbnN0YW5jZW9mIFdpbmRvdykge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLmRlYm91bmNlZFJlc2l6ZSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53cmFwcGVyUmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIodGhpcy5kZWJvdW5jZWRSZXNpemUpO1xuICAgICAgICB0aGlzLndyYXBwZXJSZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMud3JhcHBlcik7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRlbnRSZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcih0aGlzLmRlYm91bmNlZFJlc2l6ZSk7XG4gICAgICB0aGlzLmNvbnRlbnRSZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuY29udGVudCk7XG4gICAgfVxuICAgIHRoaXMucmVzaXplKCk7XG4gIH1cbiAgd2lkdGggPSAwO1xuICBoZWlnaHQgPSAwO1xuICBzY3JvbGxIZWlnaHQgPSAwO1xuICBzY3JvbGxXaWR0aCA9IDA7XG4gIC8vIFRoZXNlIGFyZSBpbnN0YW5jaWF0ZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGFzIHRoZXkgbmVlZCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBvcHRpb25zXG4gIGRlYm91bmNlZFJlc2l6ZTtcbiAgd3JhcHBlclJlc2l6ZU9ic2VydmVyO1xuICBjb250ZW50UmVzaXplT2JzZXJ2ZXI7XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy53cmFwcGVyUmVzaXplT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLmNvbnRlbnRSZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgIGlmICh0aGlzLndyYXBwZXIgPT09IHdpbmRvdyAmJiB0aGlzLmRlYm91bmNlZFJlc2l6ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5kZWJvdW5jZWRSZXNpemUsIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmVzaXplID0gKCkgPT4ge1xuICAgIHRoaXMub25XcmFwcGVyUmVzaXplKCk7XG4gICAgdGhpcy5vbkNvbnRlbnRSZXNpemUoKTtcbiAgfTtcbiAgb25XcmFwcGVyUmVzaXplID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLndyYXBwZXIgaW5zdGFuY2VvZiBXaW5kb3cpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy53cmFwcGVyLmNsaWVudFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuICAgIH1cbiAgfTtcbiAgb25Db250ZW50UmVzaXplID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLndyYXBwZXIgaW5zdGFuY2VvZiBXaW5kb3cpIHtcbiAgICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gdGhpcy5jb250ZW50LnNjcm9sbEhlaWdodDtcbiAgICAgIHRoaXMuc2Nyb2xsV2lkdGggPSB0aGlzLmNvbnRlbnQuc2Nyb2xsV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gdGhpcy53cmFwcGVyLnNjcm9sbEhlaWdodDtcbiAgICAgIHRoaXMuc2Nyb2xsV2lkdGggPSB0aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGg7XG4gICAgfVxuICB9O1xuICBnZXQgbGltaXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHRoaXMuc2Nyb2xsV2lkdGggLSB0aGlzLndpZHRoLFxuICAgICAgeTogdGhpcy5zY3JvbGxIZWlnaHQgLSB0aGlzLmhlaWdodFxuICAgIH07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2NvcmUvc3JjL2VtaXR0ZXIudHNcbnZhciBFbWl0dGVyID0gY2xhc3Mge1xuICBldmVudHMgPSB7fTtcbiAgLyoqXG4gICAqIEVtaXQgYW4gZXZlbnQgd2l0aCB0aGUgZ2l2ZW4gZGF0YVxuICAgKiBAcGFyYW0gZXZlbnQgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gYXJncyBEYXRhIHRvIHBhc3MgdG8gdGhlIGV2ZW50IGhhbmRsZXJzXG4gICAqL1xuICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgbGV0IGNhbGxiYWNrcyA9IHRoaXMuZXZlbnRzW2V2ZW50XSB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjYWxsYmFja3NbaV0/LiguLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIGNhbGxiYWNrIHRvIHRoZSBldmVudFxuICAgKiBAcGFyYW0gZXZlbnQgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gY2IgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICogQHJldHVybnMgVW5zdWJzY3JpYmUgZnVuY3Rpb25cbiAgICovXG4gIG9uKGV2ZW50LCBjYikge1xuICAgIHRoaXMuZXZlbnRzW2V2ZW50XT8ucHVzaChjYikgfHwgKHRoaXMuZXZlbnRzW2V2ZW50XSA9IFtjYl0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50c1tldmVudF0gPSB0aGlzLmV2ZW50c1tldmVudF0/LmZpbHRlcigoaSkgPT4gY2IgIT09IGkpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBldmVudCBFdmVudCBuYW1lXG4gICAqIEBwYXJhbSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICAgKi9cbiAgb2ZmKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIHRoaXMuZXZlbnRzW2V2ZW50XSA9IHRoaXMuZXZlbnRzW2V2ZW50XT8uZmlsdGVyKChpKSA9PiBjYWxsYmFjayAhPT0gaSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgZXZlbnQgbGlzdGVuZXJzIGFuZCBjbGVhbiB1cFxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9jb3JlL3NyYy92aXJ0dWFsLXNjcm9sbC50c1xudmFyIExJTkVfSEVJR0hUID0gMTAwIC8gNjtcbnZhciBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IGZhbHNlIH07XG52YXIgVmlydHVhbFNjcm9sbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucyA9IHsgd2hlZWxNdWx0aXBsaWVyOiAxLCB0b3VjaE11bHRpcGxpZXI6IDEgfSkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uV2luZG93UmVzaXplLCBmYWxzZSk7XG4gICAgdGhpcy5vbldpbmRvd1Jlc2l6ZSgpO1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5vbldoZWVsLCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICB0aGlzLm9uVG91Y2hTdGFydCxcbiAgICAgIGxpc3RlbmVyT3B0aW9uc1xuICAgICk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcInRvdWNobW92ZVwiLFxuICAgICAgdGhpcy5vblRvdWNoTW92ZSxcbiAgICAgIGxpc3RlbmVyT3B0aW9uc1xuICAgICk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLm9uVG91Y2hFbmQsIGxpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbiAgdG91Y2hTdGFydCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgbGFzdERlbHRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICB3aW5kb3cgPSB7XG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH07XG4gIGVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAvKipcbiAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gZXZlbnQgYW5kIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBFdmVudCBuYW1lXG4gICAqIEBwYXJhbSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICAgKi9cbiAgb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdHRlci5vbihldmVudCwgY2FsbGJhY2spO1xuICB9XG4gIC8qKiBSZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVycyBhbmQgY2xlYW4gdXAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmVtaXR0ZXIuZGVzdHJveSgpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25XaW5kb3dSZXNpemUsIGZhbHNlKTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMub25XaGVlbCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgdGhpcy5vblRvdWNoU3RhcnQsXG4gICAgICBsaXN0ZW5lck9wdGlvbnNcbiAgICApO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaG1vdmVcIixcbiAgICAgIHRoaXMub25Ub3VjaE1vdmUsXG4gICAgICBsaXN0ZW5lck9wdGlvbnNcbiAgICApO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaGVuZFwiLFxuICAgICAgdGhpcy5vblRvdWNoRW5kLFxuICAgICAgbGlzdGVuZXJPcHRpb25zXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgJ3RvdWNoc3RhcnQnIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBUb3VjaCBldmVudFxuICAgKi9cbiAgb25Ub3VjaFN0YXJ0ID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBldmVudC50YXJnZXRUb3VjaGVzID8gZXZlbnQudGFyZ2V0VG91Y2hlc1swXSA6IGV2ZW50O1xuICAgIHRoaXMudG91Y2hTdGFydC54ID0gY2xpZW50WDtcbiAgICB0aGlzLnRvdWNoU3RhcnQueSA9IGNsaWVudFk7XG4gICAgdGhpcy5sYXN0RGVsdGEgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJzY3JvbGxcIiwge1xuICAgICAgZGVsdGFYOiAwLFxuICAgICAgZGVsdGFZOiAwLFxuICAgICAgZXZlbnRcbiAgICB9KTtcbiAgfTtcbiAgLyoqIEV2ZW50IGhhbmRsZXIgZm9yICd0b3VjaG1vdmUnIGV2ZW50ICovXG4gIG9uVG91Y2hNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBldmVudC50YXJnZXRUb3VjaGVzID8gZXZlbnQudGFyZ2V0VG91Y2hlc1swXSA6IGV2ZW50O1xuICAgIGNvbnN0IGRlbHRhWCA9IC0oY2xpZW50WCAtIHRoaXMudG91Y2hTdGFydC54KSAqIHRoaXMub3B0aW9ucy50b3VjaE11bHRpcGxpZXI7XG4gICAgY29uc3QgZGVsdGFZID0gLShjbGllbnRZIC0gdGhpcy50b3VjaFN0YXJ0LnkpICogdGhpcy5vcHRpb25zLnRvdWNoTXVsdGlwbGllcjtcbiAgICB0aGlzLnRvdWNoU3RhcnQueCA9IGNsaWVudFg7XG4gICAgdGhpcy50b3VjaFN0YXJ0LnkgPSBjbGllbnRZO1xuICAgIHRoaXMubGFzdERlbHRhID0ge1xuICAgICAgeDogZGVsdGFYLFxuICAgICAgeTogZGVsdGFZXG4gICAgfTtcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInNjcm9sbFwiLCB7XG4gICAgICBkZWx0YVgsXG4gICAgICBkZWx0YVksXG4gICAgICBldmVudFxuICAgIH0pO1xuICB9O1xuICBvblRvdWNoRW5kID0gKGV2ZW50KSA9PiB7XG4gICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJzY3JvbGxcIiwge1xuICAgICAgZGVsdGFYOiB0aGlzLmxhc3REZWx0YS54LFxuICAgICAgZGVsdGFZOiB0aGlzLmxhc3REZWx0YS55LFxuICAgICAgZXZlbnRcbiAgICB9KTtcbiAgfTtcbiAgLyoqIEV2ZW50IGhhbmRsZXIgZm9yICd3aGVlbCcgZXZlbnQgKi9cbiAgb25XaGVlbCA9IChldmVudCkgPT4ge1xuICAgIGxldCB7IGRlbHRhWCwgZGVsdGFZLCBkZWx0YU1vZGUgfSA9IGV2ZW50O1xuICAgIGNvbnN0IG11bHRpcGxpZXJYID0gZGVsdGFNb2RlID09PSAxID8gTElORV9IRUlHSFQgOiBkZWx0YU1vZGUgPT09IDIgPyB0aGlzLndpbmRvdy53aWR0aCA6IDE7XG4gICAgY29uc3QgbXVsdGlwbGllclkgPSBkZWx0YU1vZGUgPT09IDEgPyBMSU5FX0hFSUdIVCA6IGRlbHRhTW9kZSA9PT0gMiA/IHRoaXMud2luZG93LmhlaWdodCA6IDE7XG4gICAgZGVsdGFYICo9IG11bHRpcGxpZXJYO1xuICAgIGRlbHRhWSAqPSBtdWx0aXBsaWVyWTtcbiAgICBkZWx0YVggKj0gdGhpcy5vcHRpb25zLndoZWVsTXVsdGlwbGllcjtcbiAgICBkZWx0YVkgKj0gdGhpcy5vcHRpb25zLndoZWVsTXVsdGlwbGllcjtcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInNjcm9sbFwiLCB7IGRlbHRhWCwgZGVsdGFZLCBldmVudCB9KTtcbiAgfTtcbiAgb25XaW5kb3dSZXNpemUgPSAoKSA9PiB7XG4gICAgdGhpcy53aW5kb3cgPSB7XG4gICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuICAgIH07XG4gIH07XG59O1xuXG4vLyBwYWNrYWdlcy9jb3JlL3NyYy9sZW5pcy50c1xudmFyIGRlZmF1bHRFYXNpbmcgPSAodCkgPT4gTWF0aC5taW4oMSwgMS4wMDEgLSBNYXRoLnBvdygyLCAtMTAgKiB0KSk7XG52YXIgTGVuaXMgPSBjbGFzcyB7XG4gIF9pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAvLyB0cnVlIHdoZW4gc2Nyb2xsIGlzIGFuaW1hdGluZ1xuICBfaXNTdG9wcGVkID0gZmFsc2U7XG4gIC8vIHRydWUgaWYgdXNlciBzaG91bGQgbm90IGJlIGFibGUgdG8gc2Nyb2xsIC0gZW5hYmxlL2Rpc2FibGUgcHJvZ3JhbW1hdGljYWxseVxuICBfaXNMb2NrZWQgPSBmYWxzZTtcbiAgLy8gc2FtZSBhcyBpc1N0b3BwZWQgYnV0IGVuYWJsZWQvZGlzYWJsZWQgd2hlbiBzY3JvbGwgcmVhY2hlcyB0YXJnZXRcbiAgX3ByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQgPSBmYWxzZTtcbiAgX3Jlc2V0VmVsb2NpdHlUaW1lb3V0ID0gbnVsbDtcbiAgX19yYWZJRCA9IG51bGw7XG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgdXNlciBpcyB0b3VjaGluZyB0aGUgc2NyZWVuXG4gICAqL1xuICBpc1RvdWNoaW5nO1xuICAvKipcbiAgICogVGhlIHRpbWUgaW4gbXMgc2luY2UgdGhlIGxlbmlzIGluc3RhbmNlIHdhcyBjcmVhdGVkXG4gICAqL1xuICB0aW1lID0gMDtcbiAgLyoqXG4gICAqIFVzZXIgZGF0YSB0aGF0IHdpbGwgYmUgZm9yd2FyZGVkIHRocm91Z2ggdGhlIHNjcm9sbCBldmVudFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBsZW5pcy5zY3JvbGxUbygxMDAsIHtcbiAgICogICB1c2VyRGF0YToge1xuICAgKiAgICAgZm9vOiAnYmFyJ1xuICAgKiAgIH1cbiAgICogfSlcbiAgICovXG4gIHVzZXJEYXRhID0ge307XG4gIC8qKlxuICAgKiBUaGUgbGFzdCB2ZWxvY2l0eSBvZiB0aGUgc2Nyb2xsXG4gICAqL1xuICBsYXN0VmVsb2NpdHkgPSAwO1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgdmVsb2NpdHkgb2YgdGhlIHNjcm9sbFxuICAgKi9cbiAgdmVsb2NpdHkgPSAwO1xuICAvKipcbiAgICogVGhlIGRpcmVjdGlvbiBvZiB0aGUgc2Nyb2xsXG4gICAqL1xuICBkaXJlY3Rpb24gPSAwO1xuICAvKipcbiAgICogVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBsZW5pcyBpbnN0YW5jZVxuICAgKi9cbiAgb3B0aW9ucztcbiAgLyoqXG4gICAqIFRoZSB0YXJnZXQgc2Nyb2xsIHZhbHVlXG4gICAqL1xuICB0YXJnZXRTY3JvbGw7XG4gIC8qKlxuICAgKiBUaGUgYW5pbWF0ZWQgc2Nyb2xsIHZhbHVlXG4gICAqL1xuICBhbmltYXRlZFNjcm9sbDtcbiAgLy8gVGhlc2UgYXJlIGluc3RhbmNpYXRlZCBoZXJlIGFzIHRoZXkgZG9uJ3QgbmVlZCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBvcHRpb25zXG4gIGFuaW1hdGUgPSBuZXcgQW5pbWF0ZSgpO1xuICBlbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgLy8gVGhlc2UgYXJlIGluc3RhbmNpYXRlZCBpbiB0aGUgY29uc3RydWN0b3IgYXMgdGhleSBuZWVkIGluZm9ybWF0aW9uIGZyb20gdGhlIG9wdGlvbnNcbiAgZGltZW5zaW9ucztcbiAgLy8gVGhpcyBpcyBub3QgcHJpdmF0ZSBiZWNhdXNlIGl0J3MgdXNlZCBpbiB0aGUgU25hcCBjbGFzc1xuICB2aXJ0dWFsU2Nyb2xsO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgd3JhcHBlciA9IHdpbmRvdyxcbiAgICBjb250ZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgIGV2ZW50c1RhcmdldCA9IHdyYXBwZXIsXG4gICAgc21vb3RoV2hlZWwgPSB0cnVlLFxuICAgIHN5bmNUb3VjaCA9IGZhbHNlLFxuICAgIHN5bmNUb3VjaExlcnAgPSAwLjA3NSxcbiAgICB0b3VjaEluZXJ0aWFFeHBvbmVudCA9IDEuNyxcbiAgICBkdXJhdGlvbixcbiAgICAvLyBpbiBzZWNvbmRzXG4gICAgZWFzaW5nLFxuICAgIGxlcnA6IGxlcnAyID0gMC4xLFxuICAgIGluZmluaXRlID0gZmFsc2UsXG4gICAgb3JpZW50YXRpb24gPSBcInZlcnRpY2FsXCIsXG4gICAgLy8gdmVydGljYWwsIGhvcml6b250YWxcbiAgICBnZXN0dXJlT3JpZW50YXRpb24gPSBvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcImJvdGhcIiA6IFwidmVydGljYWxcIixcbiAgICAvLyB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCwgYm90aFxuICAgIHRvdWNoTXVsdGlwbGllciA9IDEsXG4gICAgd2hlZWxNdWx0aXBsaWVyID0gMSxcbiAgICBhdXRvUmVzaXplID0gdHJ1ZSxcbiAgICBwcmV2ZW50LFxuICAgIHZpcnR1YWxTY3JvbGwsXG4gICAgb3ZlcnNjcm9sbCA9IHRydWUsXG4gICAgYXV0b1JhZiA9IGZhbHNlLFxuICAgIGFuY2hvcnMgPSBmYWxzZSxcbiAgICBhdXRvVG9nZ2xlID0gZmFsc2UsXG4gICAgLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8/c2VhcmNoPXRyYW5zaXRpb24tYmVoYXZpb3JcbiAgICBhbGxvd05lc3RlZFNjcm9sbCA9IGZhbHNlLFxuICAgIF9fZXhwZXJpbWVudGFsX19uYWl2ZURpbWVuc2lvbnMgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICB3aW5kb3cubGVuaXNWZXJzaW9uID0gdmVyc2lvbjtcbiAgICBpZiAoIXdyYXBwZXIgfHwgd3JhcHBlciA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICB3cmFwcGVyID0gd2luZG93O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGR1cmF0aW9uID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBlYXNpbmcgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZWFzaW5nID0gZGVmYXVsdEVhc2luZztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlYXNpbmcgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZHVyYXRpb24gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGR1cmF0aW9uID0gMTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgd3JhcHBlcixcbiAgICAgIGNvbnRlbnQsXG4gICAgICBldmVudHNUYXJnZXQsXG4gICAgICBzbW9vdGhXaGVlbCxcbiAgICAgIHN5bmNUb3VjaCxcbiAgICAgIHN5bmNUb3VjaExlcnAsXG4gICAgICB0b3VjaEluZXJ0aWFFeHBvbmVudCxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgZWFzaW5nLFxuICAgICAgbGVycDogbGVycDIsXG4gICAgICBpbmZpbml0ZSxcbiAgICAgIGdlc3R1cmVPcmllbnRhdGlvbixcbiAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgdG91Y2hNdWx0aXBsaWVyLFxuICAgICAgd2hlZWxNdWx0aXBsaWVyLFxuICAgICAgYXV0b1Jlc2l6ZSxcbiAgICAgIHByZXZlbnQsXG4gICAgICB2aXJ0dWFsU2Nyb2xsLFxuICAgICAgb3ZlcnNjcm9sbCxcbiAgICAgIGF1dG9SYWYsXG4gICAgICBhbmNob3JzLFxuICAgICAgYXV0b1RvZ2dsZSxcbiAgICAgIGFsbG93TmVzdGVkU2Nyb2xsLFxuICAgICAgX19leHBlcmltZW50YWxfX25haXZlRGltZW5zaW9uc1xuICAgIH07XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IERpbWVuc2lvbnMod3JhcHBlciwgY29udGVudCwgeyBhdXRvUmVzaXplIH0pO1xuICAgIHRoaXMudXBkYXRlQ2xhc3NOYW1lKCk7XG4gICAgdGhpcy50YXJnZXRTY3JvbGwgPSB0aGlzLmFuaW1hdGVkU2Nyb2xsID0gdGhpcy5hY3R1YWxTY3JvbGw7XG4gICAgdGhpcy5vcHRpb25zLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uTmF0aXZlU2Nyb2xsLCBmYWxzZSk7XG4gICAgdGhpcy5vcHRpb25zLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCB0aGlzLm9uU2Nyb2xsRW5kLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hbmNob3JzICYmIHRoaXMub3B0aW9ucy53cmFwcGVyID09PSB3aW5kb3cpIHtcbiAgICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY2xpY2tcIixcbiAgICAgICAgdGhpcy5vbkNsaWNrLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwicG9pbnRlcmRvd25cIixcbiAgICAgIHRoaXMub25Qb2ludGVyRG93bixcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICB0aGlzLnZpcnR1YWxTY3JvbGwgPSBuZXcgVmlydHVhbFNjcm9sbChldmVudHNUYXJnZXQsIHtcbiAgICAgIHRvdWNoTXVsdGlwbGllcixcbiAgICAgIHdoZWVsTXVsdGlwbGllclxuICAgIH0pO1xuICAgIHRoaXMudmlydHVhbFNjcm9sbC5vbihcInNjcm9sbFwiLCB0aGlzLm9uVmlydHVhbFNjcm9sbCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvVG9nZ2xlKSB7XG4gICAgICB0aGlzLnJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIHRoaXMub25UcmFuc2l0aW9uRW5kLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9SYWYpIHtcbiAgICAgIHRoaXMuX19yYWZJRCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJhZik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBsZW5pcyBpbnN0YW5jZSwgcmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMgYW5kIGNsZWFuIHVwIHRoZSBjbGFzcyBuYW1lXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZW1pdHRlci5kZXN0cm95KCk7XG4gICAgdGhpcy5vcHRpb25zLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwic2Nyb2xsXCIsXG4gICAgICB0aGlzLm9uTmF0aXZlU2Nyb2xsLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxlbmRcIiwgdGhpcy5vblNjcm9sbEVuZCwge1xuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBcInBvaW50ZXJkb3duXCIsXG4gICAgICB0aGlzLm9uUG9pbnRlckRvd24sXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hbmNob3JzICYmIHRoaXMub3B0aW9ucy53cmFwcGVyID09PSB3aW5kb3cpIHtcbiAgICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY2xpY2tcIixcbiAgICAgICAgdGhpcy5vbkNsaWNrLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy52aXJ0dWFsU2Nyb2xsLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRpbWVuc2lvbnMuZGVzdHJveSgpO1xuICAgIHRoaXMuY2xlYW5VcENsYXNzTmFtZSgpO1xuICAgIGlmICh0aGlzLl9fcmFmSUQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX19yYWZJRCk7XG4gICAgfVxuICB9XG4gIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmVtaXR0ZXIub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgfVxuICBvZmYoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdHRlci5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgfVxuICBvblNjcm9sbEVuZCA9IChlKSA9PiB7XG4gICAgaWYgKCEoZSBpbnN0YW5jZW9mIEN1c3RvbUV2ZW50KSkge1xuICAgICAgaWYgKHRoaXMuaXNTY3JvbGxpbmcgPT09IFwic21vb3RoXCIgfHwgdGhpcy5pc1Njcm9sbGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGRpc3BhdGNoU2Nyb2xsZW5kRXZlbnQgPSAoKSA9PiB7XG4gICAgdGhpcy5vcHRpb25zLndyYXBwZXIuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBDdXN0b21FdmVudChcInNjcm9sbGVuZFwiLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRoaXMub3B0aW9ucy53cmFwcGVyID09PSB3aW5kb3csXG4gICAgICAgIC8vIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICBsZW5pc1Njcm9sbEVuZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH07XG4gIG9uVHJhbnNpdGlvbkVuZCA9IChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5wcm9wZXJ0eU5hbWUuaW5jbHVkZXMoXCJvdmVyZmxvd1wiKSkge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSB0aGlzLmlzSG9yaXpvbnRhbCA/IFwib3ZlcmZsb3cteFwiIDogXCJvdmVyZmxvdy15XCI7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5yb290RWxlbWVudClbcHJvcGVydHldO1xuICAgICAgaWYgKFtcImhpZGRlblwiLCBcImNsaXBcIl0uaW5jbHVkZXMob3ZlcmZsb3cpKSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxTdG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludGVybmFsU3RhcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFNjcm9sbChzY3JvbGwpIHtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLnNjcm9sbFRvKHsgbGVmdDogc2Nyb2xsLCBiZWhhdmlvcjogXCJpbnN0YW50XCIgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLnNjcm9sbFRvKHsgdG9wOiBzY3JvbGwsIGJlaGF2aW9yOiBcImluc3RhbnRcIiB9KTtcbiAgICB9XG4gIH1cbiAgb25DbGljayA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IHBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICBjb25zdCBhbmNob3IgPSBwYXRoLmZpbmQoXG4gICAgICAobm9kZSkgPT4gbm9kZSBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50ICYmIG5vZGUuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKT8uaW5jbHVkZXMoXCIjXCIpXG4gICAgKTtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICBjb25zdCBocmVmID0gYW5jaG9yLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICBpZiAoaHJlZikge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIHRoaXMub3B0aW9ucy5hbmNob3JzID09PSBcIm9iamVjdFwiICYmIHRoaXMub3B0aW9ucy5hbmNob3JzID8gdGhpcy5vcHRpb25zLmFuY2hvcnMgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGAjJHtocmVmLnNwbGl0KFwiI1wiKVsxXX1gO1xuICAgICAgICB0aGlzLnNjcm9sbFRvKHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBvblBvaW50ZXJEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgfTtcbiAgb25WaXJ0dWFsU2Nyb2xsID0gKGRhdGEpID0+IHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy52aXJ0dWFsU2Nyb2xsID09PSBcImZ1bmN0aW9uXCIgJiYgdGhpcy5vcHRpb25zLnZpcnR1YWxTY3JvbGwoZGF0YSkgPT09IGZhbHNlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgZGVsdGFYLCBkZWx0YVksIGV2ZW50IH0gPSBkYXRhO1xuICAgIHRoaXMuZW1pdHRlci5lbWl0KFwidmlydHVhbC1zY3JvbGxcIiwgeyBkZWx0YVgsIGRlbHRhWSwgZXZlbnQgfSk7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpIHJldHVybjtcbiAgICBpZiAoZXZlbnQubGVuaXNTdG9wUHJvcGFnYXRpb24pIHJldHVybjtcbiAgICBjb25zdCBpc1RvdWNoID0gZXZlbnQudHlwZS5pbmNsdWRlcyhcInRvdWNoXCIpO1xuICAgIGNvbnN0IGlzV2hlZWwgPSBldmVudC50eXBlLmluY2x1ZGVzKFwid2hlZWxcIik7XG4gICAgdGhpcy5pc1RvdWNoaW5nID0gZXZlbnQudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIgfHwgZXZlbnQudHlwZSA9PT0gXCJ0b3VjaG1vdmVcIjtcbiAgICBjb25zdCBpc0NsaWNrT3JUYXAgPSBkZWx0YVggPT09IDAgJiYgZGVsdGFZID09PSAwO1xuICAgIGNvbnN0IGlzVGFwVG9TdG9wID0gdGhpcy5vcHRpb25zLnN5bmNUb3VjaCAmJiBpc1RvdWNoICYmIGV2ZW50LnR5cGUgPT09IFwidG91Y2hzdGFydFwiICYmIGlzQ2xpY2tPclRhcCAmJiAhdGhpcy5pc1N0b3BwZWQgJiYgIXRoaXMuaXNMb2NrZWQ7XG4gICAgaWYgKGlzVGFwVG9TdG9wKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzVW5rbm93bkdlc3R1cmUgPSB0aGlzLm9wdGlvbnMuZ2VzdHVyZU9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgJiYgZGVsdGFZID09PSAwIHx8IHRoaXMub3B0aW9ucy5nZXN0dXJlT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICYmIGRlbHRhWCA9PT0gMDtcbiAgICBpZiAoaXNDbGlja09yVGFwIHx8IGlzVW5rbm93bkdlc3R1cmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNvbXBvc2VkUGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgIGNvbXBvc2VkUGF0aCA9IGNvbXBvc2VkUGF0aC5zbGljZSgwLCBjb21wb3NlZFBhdGguaW5kZXhPZih0aGlzLnJvb3RFbGVtZW50KSk7XG4gICAgY29uc3QgcHJldmVudCA9IHRoaXMub3B0aW9ucy5wcmV2ZW50O1xuICAgIGlmICghIWNvbXBvc2VkUGF0aC5maW5kKFxuICAgICAgKG5vZGUpID0+IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiAodHlwZW9mIHByZXZlbnQgPT09IFwiZnVuY3Rpb25cIiAmJiBwcmV2ZW50Py4obm9kZSkgfHwgbm9kZS5oYXNBdHRyaWJ1dGU/LihcImRhdGEtbGVuaXMtcHJldmVudFwiKSB8fCBpc1RvdWNoICYmIG5vZGUuaGFzQXR0cmlidXRlPy4oXCJkYXRhLWxlbmlzLXByZXZlbnQtdG91Y2hcIikgfHwgaXNXaGVlbCAmJiBub2RlLmhhc0F0dHJpYnV0ZT8uKFwiZGF0YS1sZW5pcy1wcmV2ZW50LXdoZWVsXCIpIHx8IHRoaXMub3B0aW9ucy5hbGxvd05lc3RlZFNjcm9sbCAmJiB0aGlzLmNoZWNrTmVzdGVkU2Nyb2xsKG5vZGUsIHsgZGVsdGFYLCBkZWx0YVkgfSkpXG4gICAgKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5pc1N0b3BwZWQgfHwgdGhpcy5pc0xvY2tlZCkge1xuICAgICAgaWYgKGV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNTbW9vdGggPSB0aGlzLm9wdGlvbnMuc3luY1RvdWNoICYmIGlzVG91Y2ggfHwgdGhpcy5vcHRpb25zLnNtb290aFdoZWVsICYmIGlzV2hlZWw7XG4gICAgaWYgKCFpc1Ntb290aCkge1xuICAgICAgdGhpcy5pc1Njcm9sbGluZyA9IFwibmF0aXZlXCI7XG4gICAgICB0aGlzLmFuaW1hdGUuc3RvcCgpO1xuICAgICAgZXZlbnQubGVuaXNTdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZGVsdGEgPSBkZWx0YVk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5nZXN0dXJlT3JpZW50YXRpb24gPT09IFwiYm90aFwiKSB7XG4gICAgICBkZWx0YSA9IE1hdGguYWJzKGRlbHRhWSkgPiBNYXRoLmFicyhkZWx0YVgpID8gZGVsdGFZIDogZGVsdGFYO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgIGRlbHRhID0gZGVsdGFYO1xuICAgIH1cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5vdmVyc2Nyb2xsIHx8IHRoaXMub3B0aW9ucy5pbmZpbml0ZSB8fCB0aGlzLm9wdGlvbnMud3JhcHBlciAhPT0gd2luZG93ICYmIHRoaXMubGltaXQgPiAwICYmICh0aGlzLmFuaW1hdGVkU2Nyb2xsID4gMCAmJiB0aGlzLmFuaW1hdGVkU2Nyb2xsIDwgdGhpcy5saW1pdCB8fCB0aGlzLmFuaW1hdGVkU2Nyb2xsID09PSAwICYmIGRlbHRhWSA+IDAgfHwgdGhpcy5hbmltYXRlZFNjcm9sbCA9PT0gdGhpcy5saW1pdCAmJiBkZWx0YVkgPCAwKSkge1xuICAgICAgZXZlbnQubGVuaXNTdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgY29uc3QgaXNTeW5jVG91Y2ggPSBpc1RvdWNoICYmIHRoaXMub3B0aW9ucy5zeW5jVG91Y2g7XG4gICAgY29uc3QgaXNUb3VjaEVuZCA9IGlzVG91Y2ggJiYgZXZlbnQudHlwZSA9PT0gXCJ0b3VjaGVuZFwiO1xuICAgIGNvbnN0IGhhc1RvdWNoSW5lcnRpYSA9IGlzVG91Y2hFbmQ7XG4gICAgaWYgKGhhc1RvdWNoSW5lcnRpYSkge1xuICAgICAgZGVsdGEgPSBNYXRoLnNpZ24odGhpcy52ZWxvY2l0eSkgKiBNYXRoLnBvdyhNYXRoLmFicyh0aGlzLnZlbG9jaXR5KSwgdGhpcy5vcHRpb25zLnRvdWNoSW5lcnRpYUV4cG9uZW50KTtcbiAgICB9XG4gICAgdGhpcy5zY3JvbGxUbyh0aGlzLnRhcmdldFNjcm9sbCArIGRlbHRhLCB7XG4gICAgICBwcm9ncmFtbWF0aWM6IGZhbHNlLFxuICAgICAgLi4uaXNTeW5jVG91Y2ggPyB7XG4gICAgICAgIGxlcnA6IGhhc1RvdWNoSW5lcnRpYSA/IHRoaXMub3B0aW9ucy5zeW5jVG91Y2hMZXJwIDogMVxuICAgICAgICAvLyBpbW1lZGlhdGU6ICFoYXNUb3VjaEluZXJ0aWEsXG4gICAgICB9IDoge1xuICAgICAgICBsZXJwOiB0aGlzLm9wdGlvbnMubGVycCxcbiAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiB0aGlzLm9wdGlvbnMuZWFzaW5nXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBGb3JjZSBsZW5pcyB0byByZWNhbGN1bGF0ZSB0aGUgZGltZW5zaW9uc1xuICAgKi9cbiAgcmVzaXplKCkge1xuICAgIHRoaXMuZGltZW5zaW9ucy5yZXNpemUoKTtcbiAgICB0aGlzLmFuaW1hdGVkU2Nyb2xsID0gdGhpcy50YXJnZXRTY3JvbGwgPSB0aGlzLmFjdHVhbFNjcm9sbDtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBlbWl0KCkge1xuICAgIHRoaXMuZW1pdHRlci5lbWl0KFwic2Nyb2xsXCIsIHRoaXMpO1xuICB9XG4gIG9uTmF0aXZlU2Nyb2xsID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLl9yZXNldFZlbG9jaXR5VGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2V0VmVsb2NpdHlUaW1lb3V0KTtcbiAgICAgIHRoaXMuX3Jlc2V0VmVsb2NpdHlUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3ByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQpIHtcbiAgICAgIHRoaXMuX3ByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTY3JvbGxpbmcgPT09IGZhbHNlIHx8IHRoaXMuaXNTY3JvbGxpbmcgPT09IFwibmF0aXZlXCIpIHtcbiAgICAgIGNvbnN0IGxhc3RTY3JvbGwgPSB0aGlzLmFuaW1hdGVkU2Nyb2xsO1xuICAgICAgdGhpcy5hbmltYXRlZFNjcm9sbCA9IHRoaXMudGFyZ2V0U2Nyb2xsID0gdGhpcy5hY3R1YWxTY3JvbGw7XG4gICAgICB0aGlzLmxhc3RWZWxvY2l0eSA9IHRoaXMudmVsb2NpdHk7XG4gICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy5hbmltYXRlZFNjcm9sbCAtIGxhc3RTY3JvbGw7XG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IE1hdGguc2lnbihcbiAgICAgICAgdGhpcy5hbmltYXRlZFNjcm9sbCAtIGxhc3RTY3JvbGxcbiAgICAgICk7XG4gICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBcIm5hdGl2ZVwiO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCk7XG4gICAgICBpZiAodGhpcy52ZWxvY2l0eSAhPT0gMCkge1xuICAgICAgICB0aGlzLl9yZXNldFZlbG9jaXR5VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMubGFzdFZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eTtcbiAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5lbWl0KCk7XG4gICAgICAgIH0sIDQwMCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXNldCgpIHtcbiAgICB0aGlzLmlzTG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy5pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuYW5pbWF0ZWRTY3JvbGwgPSB0aGlzLnRhcmdldFNjcm9sbCA9IHRoaXMuYWN0dWFsU2Nyb2xsO1xuICAgIHRoaXMubGFzdFZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eSA9IDA7XG4gICAgdGhpcy5hbmltYXRlLnN0b3AoKTtcbiAgfVxuICAvKipcbiAgICogU3RhcnQgbGVuaXMgc2Nyb2xsIGFmdGVyIGl0IGhhcyBiZWVuIHN0b3BwZWRcbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHJldHVybjtcbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9Ub2dnbGUpIHtcbiAgICAgIHRoaXMucm9vdEVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJvdmVyZmxvd1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pbnRlcm5hbFN0YXJ0KCk7XG4gIH1cbiAgaW50ZXJuYWxTdGFydCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSByZXR1cm47XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3AgbGVuaXMgc2Nyb2xsXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1RvZ2dsZSkge1xuICAgICAgdGhpcy5yb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIm92ZXJmbG93XCIsIFwiY2xpcFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pbnRlcm5hbFN0b3AoKTtcbiAgfVxuICBpbnRlcm5hbFN0b3AoKSB7XG4gICAgaWYgKHRoaXMuaXNTdG9wcGVkKSByZXR1cm47XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZvciBsZW5pc1xuICAgKlxuICAgKiBAcGFyYW0gdGltZSBUaGUgdGltZSBpbiBtcyBmcm9tIGFuIGV4dGVybmFsIGNsb2NrIGxpa2UgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgb3IgVGVtcHVzXG4gICAqL1xuICByYWYgPSAodGltZSkgPT4ge1xuICAgIGNvbnN0IGRlbHRhVGltZSA9IHRpbWUgLSAodGhpcy50aW1lIHx8IHRpbWUpO1xuICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgdGhpcy5hbmltYXRlLmFkdmFuY2UoZGVsdGFUaW1lICogMWUtMyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUmFmKSB7XG4gICAgICB0aGlzLl9fcmFmSUQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yYWYpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFNjcm9sbCB0byBhIHRhcmdldCB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgdmFsdWUgdG8gc2Nyb2xsIHRvXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgc2Nyb2xsXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGxlbmlzLnNjcm9sbFRvKDEwMCwge1xuICAgKiAgIG9mZnNldDogMTAwLFxuICAgKiAgIGR1cmF0aW9uOiAxLFxuICAgKiAgIGVhc2luZzogKHQpID0+IDEgLSBNYXRoLmNvcygodCAqIE1hdGguUEkpIC8gMiksXG4gICAqICAgbGVycDogMC4xLFxuICAgKiAgIG9uU3RhcnQ6ICgpID0+IHtcbiAgICogICAgIGNvbnNvbGUubG9nKCdvblN0YXJ0JylcbiAgICogICB9LFxuICAgKiAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICogICAgIGNvbnNvbGUubG9nKCdvbkNvbXBsZXRlJylcbiAgICogICB9LFxuICAgKiB9KVxuICAgKi9cbiAgc2Nyb2xsVG8odGFyZ2V0LCB7XG4gICAgb2Zmc2V0ID0gMCxcbiAgICBpbW1lZGlhdGUgPSBmYWxzZSxcbiAgICBsb2NrID0gZmFsc2UsXG4gICAgZHVyYXRpb24gPSB0aGlzLm9wdGlvbnMuZHVyYXRpb24sXG4gICAgZWFzaW5nID0gdGhpcy5vcHRpb25zLmVhc2luZyxcbiAgICBsZXJwOiBsZXJwMiA9IHRoaXMub3B0aW9ucy5sZXJwLFxuICAgIG9uU3RhcnQsXG4gICAgb25Db21wbGV0ZSxcbiAgICBmb3JjZSA9IGZhbHNlLFxuICAgIC8vIHNjcm9sbCBldmVuIGlmIHN0b3BwZWRcbiAgICBwcm9ncmFtbWF0aWMgPSB0cnVlLFxuICAgIC8vIGNhbGxlZCBmcm9tIG91dHNpZGUgb2YgdGhlIGNsYXNzXG4gICAgdXNlckRhdGFcbiAgfSA9IHt9KSB7XG4gICAgaWYgKCh0aGlzLmlzU3RvcHBlZCB8fCB0aGlzLmlzTG9ja2VkKSAmJiAhZm9yY2UpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIiAmJiBbXCJ0b3BcIiwgXCJsZWZ0XCIsIFwic3RhcnRcIiwgXCIjXCJdLmluY2x1ZGVzKHRhcmdldCkpIHtcbiAgICAgIHRhcmdldCA9IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiICYmIFtcImJvdHRvbVwiLCBcInJpZ2h0XCIsIFwiZW5kXCJdLmluY2x1ZGVzKHRhcmdldCkpIHtcbiAgICAgIHRhcmdldCA9IHRoaXMubGltaXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBub2RlO1xuICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgaWYgKHRhcmdldCA9PT0gXCIjdG9wXCIpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkxlbmlzOiBUYXJnZXQgbm90IGZvdW5kXCIsIHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHRhcmdldD8ubm9kZVR5cGUpIHtcbiAgICAgICAgbm9kZSA9IHRhcmdldDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMud3JhcHBlciAhPT0gd2luZG93KSB7XG4gICAgICAgICAgY29uc3Qgd3JhcHBlclJlY3QgPSB0aGlzLnJvb3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIG9mZnNldCAtPSB0aGlzLmlzSG9yaXpvbnRhbCA/IHdyYXBwZXJSZWN0LmxlZnQgOiB3cmFwcGVyUmVjdC50b3A7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRhcmdldCA9ICh0aGlzLmlzSG9yaXpvbnRhbCA/IHJlY3QubGVmdCA6IHJlY3QudG9wKSArIHRoaXMuYW5pbWF0ZWRTY3JvbGw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSBcIm51bWJlclwiKSByZXR1cm47XG4gICAgdGFyZ2V0ICs9IG9mZnNldDtcbiAgICB0YXJnZXQgPSBNYXRoLnJvdW5kKHRhcmdldCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbmZpbml0ZSkge1xuICAgICAgaWYgKHByb2dyYW1tYXRpYykge1xuICAgICAgICB0aGlzLnRhcmdldFNjcm9sbCA9IHRoaXMuYW5pbWF0ZWRTY3JvbGwgPSB0aGlzLnNjcm9sbDtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0YXJnZXQgLSB0aGlzLmFuaW1hdGVkU2Nyb2xsO1xuICAgICAgICBpZiAoZGlzdGFuY2UgPiB0aGlzLmxpbWl0IC8gMikge1xuICAgICAgICAgIHRhcmdldCA9IHRhcmdldCAtIHRoaXMubGltaXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPCAtdGhpcy5saW1pdCAvIDIpIHtcbiAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQgKyB0aGlzLmxpbWl0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldCA9IGNsYW1wKDAsIHRhcmdldCwgdGhpcy5saW1pdCk7XG4gICAgfVxuICAgIGlmICh0YXJnZXQgPT09IHRoaXMudGFyZ2V0U2Nyb2xsKSB7XG4gICAgICBvblN0YXJ0Py4odGhpcyk7XG4gICAgICBvbkNvbXBsZXRlPy4odGhpcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXNlckRhdGEgPSB1c2VyRGF0YSA/PyB7fTtcbiAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICB0aGlzLmFuaW1hdGVkU2Nyb2xsID0gdGhpcy50YXJnZXRTY3JvbGwgPSB0YXJnZXQ7XG4gICAgICB0aGlzLnNldFNjcm9sbCh0aGlzLnNjcm9sbCk7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB0aGlzLnByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQoKTtcbiAgICAgIHRoaXMuZW1pdCgpO1xuICAgICAgb25Db21wbGV0ZT8uKHRoaXMpO1xuICAgICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFNjcm9sbGVuZEV2ZW50KCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwcm9ncmFtbWF0aWMpIHtcbiAgICAgIHRoaXMudGFyZ2V0U2Nyb2xsID0gdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGR1cmF0aW9uID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBlYXNpbmcgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZWFzaW5nID0gZGVmYXVsdEVhc2luZztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlYXNpbmcgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZHVyYXRpb24gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGR1cmF0aW9uID0gMTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRlLmZyb21Ubyh0aGlzLmFuaW1hdGVkU2Nyb2xsLCB0YXJnZXQsIHtcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgZWFzaW5nLFxuICAgICAgbGVycDogbGVycDIsXG4gICAgICBvblN0YXJ0OiAoKSA9PiB7XG4gICAgICAgIGlmIChsb2NrKSB0aGlzLmlzTG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc1Njcm9sbGluZyA9IFwic21vb3RoXCI7XG4gICAgICAgIG9uU3RhcnQ/Lih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBvblVwZGF0ZTogKHZhbHVlLCBjb21wbGV0ZWQpID0+IHtcbiAgICAgICAgdGhpcy5pc1Njcm9sbGluZyA9IFwic21vb3RoXCI7XG4gICAgICAgIHRoaXMubGFzdFZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eTtcbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHZhbHVlIC0gdGhpcy5hbmltYXRlZFNjcm9sbDtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBNYXRoLnNpZ24odGhpcy52ZWxvY2l0eSk7XG4gICAgICAgIHRoaXMuYW5pbWF0ZWRTY3JvbGwgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGwodGhpcy5zY3JvbGwpO1xuICAgICAgICBpZiAocHJvZ3JhbW1hdGljKSB7XG4gICAgICAgICAgdGhpcy50YXJnZXRTY3JvbGwgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbXBsZXRlZCkgdGhpcy5lbWl0KCk7XG4gICAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgdGhpcy5lbWl0KCk7XG4gICAgICAgICAgb25Db21wbGV0ZT8uKHRoaXMpO1xuICAgICAgICAgIHRoaXMudXNlckRhdGEgPSB7fTtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFNjcm9sbGVuZEV2ZW50KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5wcmV2ZW50TmV4dE5hdGl2ZVNjcm9sbEV2ZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwcmV2ZW50TmV4dE5hdGl2ZVNjcm9sbEV2ZW50KCkge1xuICAgIHRoaXMuX3ByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQgPSB0cnVlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLl9wcmV2ZW50TmV4dE5hdGl2ZVNjcm9sbEV2ZW50ID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tOZXN0ZWRTY3JvbGwobm9kZSwgeyBkZWx0YVgsIGRlbHRhWSB9KSB7XG4gICAgY29uc3QgdGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgY2FjaGUgPSBub2RlLl9sZW5pcyA/Pz0ge307XG4gICAgbGV0IGhhc092ZXJmbG93WCwgaGFzT3ZlcmZsb3dZLCBpc1Njcm9sbGFibGVYLCBpc1Njcm9sbGFibGVZLCBzY3JvbGxXaWR0aCwgc2Nyb2xsSGVpZ2h0LCBjbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0O1xuICAgIGNvbnN0IGdlc3R1cmVPcmllbnRhdGlvbiA9IHRoaXMub3B0aW9ucy5nZXN0dXJlT3JpZW50YXRpb247XG4gICAgaWYgKHRpbWUgLSAoY2FjaGUudGltZSA/PyAwKSA+IDJlMykge1xuICAgICAgY2FjaGUudGltZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgICBjYWNoZS5jb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcbiAgICAgIGNvbnN0IG92ZXJmbG93WFN0cmluZyA9IGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dYO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dZU3RyaW5nID0gY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1k7XG4gICAgICBoYXNPdmVyZmxvd1ggPSBbXCJhdXRvXCIsIFwib3ZlcmxheVwiLCBcInNjcm9sbFwiXS5pbmNsdWRlcyhvdmVyZmxvd1hTdHJpbmcpO1xuICAgICAgaGFzT3ZlcmZsb3dZID0gW1wiYXV0b1wiLCBcIm92ZXJsYXlcIiwgXCJzY3JvbGxcIl0uaW5jbHVkZXMob3ZlcmZsb3dZU3RyaW5nKTtcbiAgICAgIGNhY2hlLmhhc092ZXJmbG93WCA9IGhhc092ZXJmbG93WDtcbiAgICAgIGNhY2hlLmhhc092ZXJmbG93WSA9IGhhc092ZXJmbG93WTtcbiAgICAgIGlmICghaGFzT3ZlcmZsb3dYICYmICFoYXNPdmVyZmxvd1kpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChnZXN0dXJlT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiAmJiAhaGFzT3ZlcmZsb3dZKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoZ2VzdHVyZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiAmJiAhaGFzT3ZlcmZsb3dYKSByZXR1cm4gZmFsc2U7XG4gICAgICBzY3JvbGxXaWR0aCA9IG5vZGUuc2Nyb2xsV2lkdGg7XG4gICAgICBzY3JvbGxIZWlnaHQgPSBub2RlLnNjcm9sbEhlaWdodDtcbiAgICAgIGNsaWVudFdpZHRoID0gbm9kZS5jbGllbnRXaWR0aDtcbiAgICAgIGNsaWVudEhlaWdodCA9IG5vZGUuY2xpZW50SGVpZ2h0O1xuICAgICAgaXNTY3JvbGxhYmxlWCA9IHNjcm9sbFdpZHRoID4gY2xpZW50V2lkdGg7XG4gICAgICBpc1Njcm9sbGFibGVZID0gc2Nyb2xsSGVpZ2h0ID4gY2xpZW50SGVpZ2h0O1xuICAgICAgY2FjaGUuaXNTY3JvbGxhYmxlWCA9IGlzU2Nyb2xsYWJsZVg7XG4gICAgICBjYWNoZS5pc1Njcm9sbGFibGVZID0gaXNTY3JvbGxhYmxlWTtcbiAgICAgIGNhY2hlLnNjcm9sbFdpZHRoID0gc2Nyb2xsV2lkdGg7XG4gICAgICBjYWNoZS5zY3JvbGxIZWlnaHQgPSBzY3JvbGxIZWlnaHQ7XG4gICAgICBjYWNoZS5jbGllbnRXaWR0aCA9IGNsaWVudFdpZHRoO1xuICAgICAgY2FjaGUuY2xpZW50SGVpZ2h0ID0gY2xpZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpc1Njcm9sbGFibGVYID0gY2FjaGUuaXNTY3JvbGxhYmxlWDtcbiAgICAgIGlzU2Nyb2xsYWJsZVkgPSBjYWNoZS5pc1Njcm9sbGFibGVZO1xuICAgICAgaGFzT3ZlcmZsb3dYID0gY2FjaGUuaGFzT3ZlcmZsb3dYO1xuICAgICAgaGFzT3ZlcmZsb3dZID0gY2FjaGUuaGFzT3ZlcmZsb3dZO1xuICAgICAgc2Nyb2xsV2lkdGggPSBjYWNoZS5zY3JvbGxXaWR0aDtcbiAgICAgIHNjcm9sbEhlaWdodCA9IGNhY2hlLnNjcm9sbEhlaWdodDtcbiAgICAgIGNsaWVudFdpZHRoID0gY2FjaGUuY2xpZW50V2lkdGg7XG4gICAgICBjbGllbnRIZWlnaHQgPSBjYWNoZS5jbGllbnRIZWlnaHQ7XG4gICAgfVxuICAgIGlmICghaGFzT3ZlcmZsb3dYICYmICFoYXNPdmVyZmxvd1kgfHwgIWlzU2Nyb2xsYWJsZVggJiYgIWlzU2Nyb2xsYWJsZVkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGdlc3R1cmVPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICYmICghaGFzT3ZlcmZsb3dZIHx8ICFpc1Njcm9sbGFibGVZKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZ2VzdHVyZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiAmJiAoIWhhc092ZXJmbG93WCB8fCAhaXNTY3JvbGxhYmxlWCkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IG9yaWVudGF0aW9uO1xuICAgIGlmIChnZXN0dXJlT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICBvcmllbnRhdGlvbiA9IFwieFwiO1xuICAgIH0gZWxzZSBpZiAoZ2VzdHVyZU9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgIG9yaWVudGF0aW9uID0gXCJ5XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlzU2Nyb2xsaW5nWCA9IGRlbHRhWCAhPT0gMDtcbiAgICAgIGNvbnN0IGlzU2Nyb2xsaW5nWSA9IGRlbHRhWSAhPT0gMDtcbiAgICAgIGlmIChpc1Njcm9sbGluZ1ggJiYgaGFzT3ZlcmZsb3dYICYmIGlzU2Nyb2xsYWJsZVgpIHtcbiAgICAgICAgb3JpZW50YXRpb24gPSBcInhcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Njcm9sbGluZ1kgJiYgaGFzT3ZlcmZsb3dZICYmIGlzU2Nyb2xsYWJsZVkpIHtcbiAgICAgICAgb3JpZW50YXRpb24gPSBcInlcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvcmllbnRhdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzY3JvbGwsIG1heFNjcm9sbCwgZGVsdGEsIGhhc092ZXJmbG93LCBpc1Njcm9sbGFibGU7XG4gICAgaWYgKG9yaWVudGF0aW9uID09PSBcInhcIikge1xuICAgICAgc2Nyb2xsID0gbm9kZS5zY3JvbGxMZWZ0O1xuICAgICAgbWF4U2Nyb2xsID0gc2Nyb2xsV2lkdGggLSBjbGllbnRXaWR0aDtcbiAgICAgIGRlbHRhID0gZGVsdGFYO1xuICAgICAgaGFzT3ZlcmZsb3cgPSBoYXNPdmVyZmxvd1g7XG4gICAgICBpc1Njcm9sbGFibGUgPSBpc1Njcm9sbGFibGVYO1xuICAgIH0gZWxzZSBpZiAob3JpZW50YXRpb24gPT09IFwieVwiKSB7XG4gICAgICBzY3JvbGwgPSBub2RlLnNjcm9sbFRvcDtcbiAgICAgIG1heFNjcm9sbCA9IHNjcm9sbEhlaWdodCAtIGNsaWVudEhlaWdodDtcbiAgICAgIGRlbHRhID0gZGVsdGFZO1xuICAgICAgaGFzT3ZlcmZsb3cgPSBoYXNPdmVyZmxvd1k7XG4gICAgICBpc1Njcm9sbGFibGUgPSBpc1Njcm9sbGFibGVZO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHdpbGxTY3JvbGwgPSBkZWx0YSA+IDAgPyBzY3JvbGwgPCBtYXhTY3JvbGwgOiBzY3JvbGwgPiAwO1xuICAgIHJldHVybiB3aWxsU2Nyb2xsICYmIGhhc092ZXJmbG93ICYmIGlzU2Nyb2xsYWJsZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHJvb3QgZWxlbWVudCBvbiB3aGljaCBsZW5pcyBpcyBpbnN0YW5jZWRcbiAgICovXG4gIGdldCByb290RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyYXBwZXIgPT09IHdpbmRvdyA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IHRoaXMub3B0aW9ucy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbGltaXQgd2hpY2ggaXMgdGhlIG1heGltdW0gc2Nyb2xsIHZhbHVlXG4gICAqL1xuICBnZXQgbGltaXQoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5fX2V4cGVyaW1lbnRhbF9fbmFpdmVEaW1lbnNpb25zKSB7XG4gICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdEVsZW1lbnQuc2Nyb2xsV2lkdGggLSB0aGlzLnJvb3RFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5yb290RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbnMubGltaXRbdGhpcy5pc0hvcml6b250YWwgPyBcInhcIiA6IFwieVwiXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBzY3JvbGwgaXMgaG9yaXpvbnRhbFxuICAgKi9cbiAgZ2V0IGlzSG9yaXpvbnRhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgfVxuICAvKipcbiAgICogVGhlIGFjdHVhbCBzY3JvbGwgdmFsdWVcbiAgICovXG4gIGdldCBhY3R1YWxTY3JvbGwoKSB7XG4gICAgY29uc3Qgd3JhcHBlciA9IHRoaXMub3B0aW9ucy53cmFwcGVyO1xuICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbCA/IHdyYXBwZXIuc2Nyb2xsWCA/PyB3cmFwcGVyLnNjcm9sbExlZnQgOiB3cmFwcGVyLnNjcm9sbFkgPz8gd3JhcHBlci5zY3JvbGxUb3A7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHNjcm9sbCB2YWx1ZVxuICAgKi9cbiAgZ2V0IHNjcm9sbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmluZmluaXRlID8gbW9kdWxvKHRoaXMuYW5pbWF0ZWRTY3JvbGwsIHRoaXMubGltaXQpIDogdGhpcy5hbmltYXRlZFNjcm9sbDtcbiAgfVxuICAvKipcbiAgICogVGhlIHByb2dyZXNzIG9mIHRoZSBzY3JvbGwgcmVsYXRpdmUgdG8gdGhlIGxpbWl0XG4gICAqL1xuICBnZXQgcHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubGltaXQgPT09IDAgPyAxIDogdGhpcy5zY3JvbGwgLyB0aGlzLmxpbWl0O1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IHNjcm9sbCBzdGF0ZVxuICAgKi9cbiAgZ2V0IGlzU2Nyb2xsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Njcm9sbGluZztcbiAgfVxuICBzZXQgaXNTY3JvbGxpbmcodmFsdWUpIHtcbiAgICBpZiAodGhpcy5faXNTY3JvbGxpbmcgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9pc1Njcm9sbGluZyA9IHZhbHVlO1xuICAgICAgdGhpcy51cGRhdGVDbGFzc05hbWUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGxlbmlzIGlzIHN0b3BwZWRcbiAgICovXG4gIGdldCBpc1N0b3BwZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RvcHBlZDtcbiAgfVxuICBzZXQgaXNTdG9wcGVkKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2lzU3RvcHBlZCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2lzU3RvcHBlZCA9IHZhbHVlO1xuICAgICAgdGhpcy51cGRhdGVDbGFzc05hbWUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGxlbmlzIGlzIGxvY2tlZFxuICAgKi9cbiAgZ2V0IGlzTG9ja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0xvY2tlZDtcbiAgfVxuICBzZXQgaXNMb2NrZWQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5faXNMb2NrZWQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9pc0xvY2tlZCA9IHZhbHVlO1xuICAgICAgdGhpcy51cGRhdGVDbGFzc05hbWUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGxlbmlzIGlzIHNtb290aCBzY3JvbGxpbmdcbiAgICovXG4gIGdldCBpc1Ntb290aCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1Njcm9sbGluZyA9PT0gXCJzbW9vdGhcIjtcbiAgfVxuICAvKipcbiAgICogVGhlIGNsYXNzIG5hbWUgYXBwbGllZCB0byB0aGUgd3JhcHBlciBlbGVtZW50XG4gICAqL1xuICBnZXQgY2xhc3NOYW1lKCkge1xuICAgIGxldCBjbGFzc05hbWUgPSBcImxlbmlzXCI7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvVG9nZ2xlKSBjbGFzc05hbWUgKz0gXCIgbGVuaXMtYXV0b1RvZ2dsZVwiO1xuICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgY2xhc3NOYW1lICs9IFwiIGxlbmlzLXN0b3BwZWRcIjtcbiAgICBpZiAodGhpcy5pc0xvY2tlZCkgY2xhc3NOYW1lICs9IFwiIGxlbmlzLWxvY2tlZFwiO1xuICAgIGlmICh0aGlzLmlzU2Nyb2xsaW5nKSBjbGFzc05hbWUgKz0gXCIgbGVuaXMtc2Nyb2xsaW5nXCI7XG4gICAgaWYgKHRoaXMuaXNTY3JvbGxpbmcgPT09IFwic21vb3RoXCIpIGNsYXNzTmFtZSArPSBcIiBsZW5pcy1zbW9vdGhcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG4gIHVwZGF0ZUNsYXNzTmFtZSgpIHtcbiAgICB0aGlzLmNsZWFuVXBDbGFzc05hbWUoKTtcbiAgICB0aGlzLnJvb3RFbGVtZW50LmNsYXNzTmFtZSA9IGAke3RoaXMucm9vdEVsZW1lbnQuY2xhc3NOYW1lfSAke3RoaXMuY2xhc3NOYW1lfWAudHJpbSgpO1xuICB9XG4gIGNsZWFuVXBDbGFzc05hbWUoKSB7XG4gICAgdGhpcy5yb290RWxlbWVudC5jbGFzc05hbWUgPSB0aGlzLnJvb3RFbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKC9sZW5pcygtXFx3Kyk/L2csIFwiXCIpLnRyaW0oKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIExlbmlzIGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZW5pcy5tanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iLCJjbGFtcCIsIm1pbiIsImlucHV0IiwibWF4IiwiTWF0aCIsImxlcnAiLCJ4IiwieSIsInQiLCJkYW1wIiwibGFtYmRhIiwiZGVsdGFUaW1lIiwiZXhwIiwibW9kdWxvIiwibiIsImQiLCJBbmltYXRlIiwiYWR2YW5jZSIsImlzUnVubmluZyIsImNvbXBsZXRlZCIsImR1cmF0aW9uIiwiZWFzaW5nIiwiY3VycmVudFRpbWUiLCJsaW5lYXJQcm9ncmVzcyIsImVhc2VkUHJvZ3Jlc3MiLCJ2YWx1ZSIsImZyb20iLCJ0byIsInJvdW5kIiwic3RvcCIsIm9uVXBkYXRlIiwiZnJvbVRvIiwibGVycDIiLCJvblN0YXJ0IiwiZGVib3VuY2UiLCJjYWxsYmFjayIsImRlbGF5IiwidGltZXIiLCJhcmdzIiwiY29udGV4dCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJhcHBseSIsIkRpbWVuc2lvbnMiLCJjb25zdHJ1Y3RvciIsIndyYXBwZXIiLCJjb250ZW50IiwiYXV0b1Jlc2l6ZSIsImRlYm91bmNlVmFsdWUiLCJ3aWR0aCIsImhlaWdodCIsInNjcm9sbEhlaWdodCIsInNjcm9sbFdpZHRoIiwicmVzaXplIiwib25XcmFwcGVyUmVzaXplIiwib25Db250ZW50UmVzaXplIiwiV2luZG93Iiwid2luZG93IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJkZWJvdW5jZWRSZXNpemUiLCJhZGRFdmVudExpc3RlbmVyIiwid3JhcHBlclJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY29udGVudFJlc2l6ZU9ic2VydmVyIiwiZGVzdHJveSIsImRpc2Nvbm5lY3QiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibGltaXQiLCJFbWl0dGVyIiwiZW1pdCIsImV2ZW50IiwiY2FsbGJhY2tzIiwiZXZlbnRzIiwiaSIsImxlbmd0aCIsIm9uIiwiY2IiLCJwdXNoIiwiZmlsdGVyIiwib2ZmIiwiTElORV9IRUlHSFQiLCJsaXN0ZW5lck9wdGlvbnMiLCJwYXNzaXZlIiwiVmlydHVhbFNjcm9sbCIsImVsZW1lbnQiLCJvcHRpb25zIiwid2hlZWxNdWx0aXBsaWVyIiwidG91Y2hNdWx0aXBsaWVyIiwidG91Y2hTdGFydCIsImxhc3REZWx0YSIsImVtaXR0ZXIiLCJvblRvdWNoU3RhcnQiLCJjbGllbnRYIiwiY2xpZW50WSIsInRhcmdldFRvdWNoZXMiLCJkZWx0YVgiLCJkZWx0YVkiLCJvblRvdWNoTW92ZSIsIm9uVG91Y2hFbmQiLCJvbldoZWVsIiwiZGVsdGFNb2RlIiwibXVsdGlwbGllclgiLCJtdWx0aXBsaWVyWSIsIm9uV2luZG93UmVzaXplIiwiZGVmYXVsdEVhc2luZyIsInBvdyIsIkxlbmlzIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJldmVudHNUYXJnZXQiLCJzbW9vdGhXaGVlbCIsInN5bmNUb3VjaCIsInN5bmNUb3VjaExlcnAiLCJ0b3VjaEluZXJ0aWFFeHBvbmVudCIsImluZmluaXRlIiwib3JpZW50YXRpb24iLCJnZXN0dXJlT3JpZW50YXRpb24iLCJwcmV2ZW50IiwidmlydHVhbFNjcm9sbCIsIm92ZXJzY3JvbGwiLCJhdXRvUmFmIiwiYW5jaG9ycyIsImF1dG9Ub2dnbGUiLCJhbGxvd05lc3RlZFNjcm9sbCIsIl9fZXhwZXJpbWVudGFsX19uYWl2ZURpbWVuc2lvbnMiLCJfaXNTY3JvbGxpbmciLCJfaXNTdG9wcGVkIiwiX2lzTG9ja2VkIiwiX3ByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQiLCJfcmVzZXRWZWxvY2l0eVRpbWVvdXQiLCJfX3JhZklEIiwidGltZSIsInVzZXJEYXRhIiwibGFzdFZlbG9jaXR5IiwidmVsb2NpdHkiLCJkaXJlY3Rpb24iLCJhbmltYXRlIiwib25TY3JvbGxFbmQiLCJlIiwiQ3VzdG9tRXZlbnQiLCJpc1Njcm9sbGluZyIsInN0b3BQcm9wYWdhdGlvbiIsImRpc3BhdGNoU2Nyb2xsZW5kRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiYnViYmxlcyIsImRldGFpbCIsImxlbmlzU2Nyb2xsRW5kIiwib25UcmFuc2l0aW9uRW5kIiwicHJvcGVydHlOYW1lIiwiaW5jbHVkZXMiLCJwcm9wZXJ0eSIsImlzSG9yaXpvbnRhbCIsIm92ZXJmbG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInJvb3RFbGVtZW50IiwiaW50ZXJuYWxTdG9wIiwiaW50ZXJuYWxTdGFydCIsIm9uQ2xpY2siLCJwYXRoIiwiY29tcG9zZWRQYXRoIiwiYW5jaG9yIiwiZmluZCIsIm5vZGUiLCJIVE1MQW5jaG9yRWxlbWVudCIsImdldEF0dHJpYnV0ZSIsImhyZWYiLCJ0YXJnZXQiLCJzcGxpdCIsInNjcm9sbFRvIiwib25Qb2ludGVyRG93biIsImJ1dHRvbiIsInJlc2V0Iiwib25WaXJ0dWFsU2Nyb2xsIiwiZGF0YSIsImN0cmxLZXkiLCJsZW5pc1N0b3BQcm9wYWdhdGlvbiIsImlzVG91Y2giLCJ0eXBlIiwiaXNXaGVlbCIsImlzVG91Y2hpbmciLCJpc0NsaWNrT3JUYXAiLCJpc1RhcFRvU3RvcCIsImlzU3RvcHBlZCIsImlzTG9ja2VkIiwiaXNVbmtub3duR2VzdHVyZSIsInNsaWNlIiwiaW5kZXhPZiIsIkhUTUxFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwiY2hlY2tOZXN0ZWRTY3JvbGwiLCJjYW5jZWxhYmxlIiwicHJldmVudERlZmF1bHQiLCJpc1Ntb290aCIsImRlbHRhIiwiYWJzIiwiYW5pbWF0ZWRTY3JvbGwiLCJpc1N5bmNUb3VjaCIsImlzVG91Y2hFbmQiLCJoYXNUb3VjaEluZXJ0aWEiLCJzaWduIiwidGFyZ2V0U2Nyb2xsIiwicHJvZ3JhbW1hdGljIiwib25OYXRpdmVTY3JvbGwiLCJsYXN0U2Nyb2xsIiwiYWN0dWFsU2Nyb2xsIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibGVuaXNWZXJzaW9uIiwiZGltZW5zaW9ucyIsInVwZGF0ZUNsYXNzTmFtZSIsImNhcHR1cmUiLCJjbGVhblVwQ2xhc3NOYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJzZXRTY3JvbGwiLCJzY3JvbGwiLCJsZWZ0IiwiYmVoYXZpb3IiLCJ0b3AiLCJzdGFydCIsInN0eWxlIiwicmVtb3ZlUHJvcGVydHkiLCJzZXRQcm9wZXJ0eSIsIm9mZnNldCIsImltbWVkaWF0ZSIsImxvY2siLCJvbkNvbXBsZXRlIiwiZm9yY2UiLCJxdWVyeVNlbGVjdG9yIiwiY29uc29sZSIsIndhcm4iLCJub2RlVHlwZSIsIndyYXBwZXJSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicmVjdCIsImRpc3RhbmNlIiwicHJldmVudE5leHROYXRpdmVTY3JvbGxFdmVudCIsIkRhdGUiLCJub3ciLCJjYWNoZSIsIl9sZW5pcyIsImhhc092ZXJmbG93WCIsImhhc092ZXJmbG93WSIsImlzU2Nyb2xsYWJsZVgiLCJpc1Njcm9sbGFibGVZIiwiY29tcHV0ZWRTdHlsZSIsIm92ZXJmbG93WFN0cmluZyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WVN0cmluZyIsIm92ZXJmbG93WSIsImlzU2Nyb2xsaW5nWCIsImlzU2Nyb2xsaW5nWSIsIm1heFNjcm9sbCIsImhhc092ZXJmbG93IiwiaXNTY3JvbGxhYmxlIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsIndpbGxTY3JvbGwiLCJzY3JvbGxYIiwic2Nyb2xsWSIsInByb2dyZXNzIiwiY2xhc3NOYW1lIiwidHJpbSIsInJlcGxhY2UiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/lenis/dist/lenis.mjs\n");

/***/ })

};
;